/**
  Juju Client version 2.
  This API facade is available on model connections.

  NOTE: this file has been generated by the generate command in js-libjuju
  on Tue 2018/11/27 16:23:14 UTC. Do not manually edit this file.
*/

'use strict';

const {autoBind, createAsyncHandler} = require('../transform.js');

/**
  Client serves client-specific API methods.
*/
class ClientV2 {

  constructor(transport, info) {
    this._transport = transport;
    this._info = info;
    this.version = 2;

    // Automatically bind all methods to instances.
    autoBind(this);
  }

  /**
    APIHostPorts returns the API host/port addresses stored in state.

    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          servers: [][]{
            address: {
              value: string,
              type: string,
              scope: string,
              spaceName: string
            },
            port: int
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  apiHostPorts(callback) {
    return new Promise((resolve, reject) => {
      const params = {};
      // Prepare the request to the Juju API.
      const req = {
        type: 'Client',
        request: 'APIHostPorts',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#APIHostPortsResult
        if (resp) {
          result = {};
          result.servers = [];
          resp['servers'] = resp['servers'] || [];
          for (let i = 0; i < resp['servers'].length; i++) {
            result.servers[i] = [];
            resp['servers'][i] = resp['servers'][i] || [];
            for (let i2 = 0; i2 < resp['servers'][i].length; i2++) {
              // github.com/juju/juju/apiserver/params#HostPort
              if (resp['servers'][i][i2]) {
                result.servers[i][i2] = {};
                // github.com/juju/juju/apiserver/params#Address
                if (resp['servers'][i][i2]['Address']) {
                  result.servers[i][i2].address = {};
                  result.servers[i][i2].address.value = resp['servers'][i][i2]['Address']['value'];
                  result.servers[i][i2].address.type = resp['servers'][i][i2]['Address']['type'];
                  result.servers[i][i2].address.scope = resp['servers'][i][i2]['Address']['scope'];
                  result.servers[i][i2].address.spaceName = resp['servers'][i][i2]['Address']['space-name'];
                }
                result.servers[i][i2].port = resp['servers'][i][i2]['port'];
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    AbortCurrentUpgrade aborts and archives the current upgrade synchronisation
    record, if any.

    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error or null if the operation succeeded.
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  abortCurrentUpgrade(callback) {
    return new Promise((resolve, reject) => {
      const params = {};
      // Prepare the request to the Juju API.
      const req = {
        type: 'Client',
        request: 'AbortCurrentUpgrade',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    There is no documentation for this method.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          url: string,
          channel: string,
          force: bool
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error or null if the operation succeeded.
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  addCharm(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#AddCharm
      if (args) {
        params = {};
        params['url'] = args.url;
        params['channel'] = args.channel;
        params['force'] = args.force;
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Client',
        request: 'AddCharm',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    AddCharmWithAuthorization adds the given charm URL (which must include
    revision) to the model, if it does not exist yet. Local charms are not
    supported, only charm store URLs. See also AddLocalCharm().  The
    authorization macaroon, args.CharmStoreMacaroon, may be omitted, in
    which case this call is equivalent to AddCharm.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          url: string,
          channel: string,
          macaroon: anything,
          force: bool
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error or null if the operation succeeded.
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  addCharmWithAuthorization(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#AddCharmWithAuthorization
      if (args) {
        params = {};
        params['url'] = args.url;
        params['channel'] = args.channel;
        // gopkg.in/macaroon.v2-unstable#Macaroon
        params['macaroon'] = args.macaroon;
        params['force'] = args.force;
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Client',
        request: 'AddCharmWithAuthorization',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    AddMachines adds new machines with the supplied parameters.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          params: []{
            series: string,
            constraints: {
              arch: string,
              container: string,
              cores: int,
              cpuPower: int,
              mem: int,
              rootDisk: int,
              tags: []string,
              instanceType: string,
              spaces: []string,
              virtType: string
            },
            jobs: []string,
            disks: []{
              pool: string,
              size: int,
              count: int
            },
            placement: {
              scope: string,
              directive: string
            },
            parentId: string,
            containerType: string,
            instanceId: string,
            nonce: string,
            hardwareCharacteristics: {
              arch: string,
              mem: int,
              rootDisk: int,
              cpuCores: int,
              cpuPower: int,
              tags: []string,
              availabilityZone: string
            },
            addresses: []{
              value: string,
              type: string,
              scope: string,
              spaceName: string
            }
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          machines: []{
            machine: string,
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  addMachines(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#AddMachines
      if (args) {
        params = {};
        params['params'] = [];
        args.params = args.params || [];
        for (let i = 0; i < args.params.length; i++) {
          // github.com/juju/juju/apiserver/params#AddMachineParams
          if (args.params[i]) {
            params['params'][i] = {};
            params['params'][i]['series'] = args.params[i].series;
            // github.com/juju/juju/constraints#Value
            if (args.params[i].constraints) {
              params['params'][i]['constraints'] = {};
              params['params'][i]['constraints']['arch'] = args.params[i].constraints.arch;
              // github.com/juju/juju/instance#ContainerType
              params['params'][i]['constraints']['container'] = args.params[i].constraints.container;
              params['params'][i]['constraints']['cores'] = args.params[i].constraints.cores;
              params['params'][i]['constraints']['cpu-power'] = args.params[i].constraints.cpuPower;
              params['params'][i]['constraints']['mem'] = args.params[i].constraints.mem;
              params['params'][i]['constraints']['root-disk'] = args.params[i].constraints.rootDisk;
              params['params'][i]['constraints']['tags'] = [];
              args.params[i].constraints.tags = args.params[i].constraints.tags || [];
              for (let i2 = 0; i2 < args.params[i].constraints.tags.length; i2++) {
                params['params'][i]['constraints']['tags'][i2] = args.params[i].constraints.tags[i2];
              }
              params['params'][i]['constraints']['instance-type'] = args.params[i].constraints.instanceType;
              params['params'][i]['constraints']['spaces'] = [];
              args.params[i].constraints.spaces = args.params[i].constraints.spaces || [];
              for (let i2 = 0; i2 < args.params[i].constraints.spaces.length; i2++) {
                params['params'][i]['constraints']['spaces'][i2] = args.params[i].constraints.spaces[i2];
              }
              params['params'][i]['constraints']['virt-type'] = args.params[i].constraints.virtType;
            }
            params['params'][i]['jobs'] = [];
            args.params[i].jobs = args.params[i].jobs || [];
            for (let i2 = 0; i2 < args.params[i].jobs.length; i2++) {
              // github.com/juju/juju/state/multiwatcher#MachineJob
              params['params'][i]['jobs'][i2] = args.params[i].jobs[i2];
            }
            params['params'][i]['disks'] = [];
            args.params[i].disks = args.params[i].disks || [];
            for (let i2 = 0; i2 < args.params[i].disks.length; i2++) {
              // github.com/juju/juju/storage#Constraints
              if (args.params[i].disks[i2]) {
                params['params'][i]['disks'][i2] = {};
                params['params'][i]['disks'][i2]['Pool'] = args.params[i].disks[i2].pool;
                params['params'][i]['disks'][i2]['Size'] = args.params[i].disks[i2].size;
                params['params'][i]['disks'][i2]['Count'] = args.params[i].disks[i2].count;
              }
            }
            // github.com/juju/juju/instance#Placement
            if (args.params[i].placement) {
              params['params'][i]['placement'] = {};
              params['params'][i]['placement']['scope'] = args.params[i].placement.scope;
              params['params'][i]['placement']['directive'] = args.params[i].placement.directive;
            }
            params['params'][i]['parent-id'] = args.params[i].parentId;
            // github.com/juju/juju/instance#ContainerType
            params['params'][i]['container-type'] = args.params[i].containerType;
            // github.com/juju/juju/instance#Id
            params['params'][i]['instance-id'] = args.params[i].instanceId;
            params['params'][i]['nonce'] = args.params[i].nonce;
            // github.com/juju/juju/instance#HardwareCharacteristics
            if (args.params[i].hardwareCharacteristics) {
              params['params'][i]['hardware-characteristics'] = {};
              params['params'][i]['hardware-characteristics']['arch'] = args.params[i].hardwareCharacteristics.arch;
              params['params'][i]['hardware-characteristics']['mem'] = args.params[i].hardwareCharacteristics.mem;
              params['params'][i]['hardware-characteristics']['root-disk'] = args.params[i].hardwareCharacteristics.rootDisk;
              params['params'][i]['hardware-characteristics']['cpu-cores'] = args.params[i].hardwareCharacteristics.cpuCores;
              params['params'][i]['hardware-characteristics']['cpu-power'] = args.params[i].hardwareCharacteristics.cpuPower;
              params['params'][i]['hardware-characteristics']['tags'] = [];
              args.params[i].hardwareCharacteristics.tags = args.params[i].hardwareCharacteristics.tags || [];
              for (let i2 = 0; i2 < args.params[i].hardwareCharacteristics.tags.length; i2++) {
                params['params'][i]['hardware-characteristics']['tags'][i2] = args.params[i].hardwareCharacteristics.tags[i2];
              }
              params['params'][i]['hardware-characteristics']['availability-zone'] = args.params[i].hardwareCharacteristics.availabilityZone;
            }
            params['params'][i]['addresses'] = [];
            args.params[i].addresses = args.params[i].addresses || [];
            for (let i2 = 0; i2 < args.params[i].addresses.length; i2++) {
              // github.com/juju/juju/apiserver/params#Address
              if (args.params[i].addresses[i2]) {
                params['params'][i]['addresses'][i2] = {};
                params['params'][i]['addresses'][i2]['value'] = args.params[i].addresses[i2].value;
                params['params'][i]['addresses'][i2]['type'] = args.params[i].addresses[i2].type;
                params['params'][i]['addresses'][i2]['scope'] = args.params[i].addresses[i2].scope;
                params['params'][i]['addresses'][i2]['space-name'] = args.params[i].addresses[i2].spaceName;
              }
            }
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Client',
        request: 'AddMachines',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#AddMachinesResults
        if (resp) {
          result = {};
          result.machines = [];
          resp['machines'] = resp['machines'] || [];
          for (let i = 0; i < resp['machines'].length; i++) {
            // github.com/juju/juju/apiserver/params#AddMachinesResult
            if (resp['machines'][i]) {
              result.machines[i] = {};
              result.machines[i].machine = resp['machines'][i]['machine'];
              // github.com/juju/juju/apiserver/params#Error
              if (resp['machines'][i]['error']) {
                result.machines[i].error = {};
                result.machines[i].error.message = resp['machines'][i]['error']['message'];
                result.machines[i].error.code = resp['machines'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['machines'][i]['error']['info']) {
                  result.machines[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.machines[i].error.info.macaroon = resp['machines'][i]['error']['info']['macaroon'];
                  result.machines[i].error.info.macaroonPath = resp['machines'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    AddMachinesV2 adds new machines with the supplied parameters.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          params: []{
            series: string,
            constraints: {
              arch: string,
              container: string,
              cores: int,
              cpuPower: int,
              mem: int,
              rootDisk: int,
              tags: []string,
              instanceType: string,
              spaces: []string,
              virtType: string
            },
            jobs: []string,
            disks: []{
              pool: string,
              size: int,
              count: int
            },
            placement: {
              scope: string,
              directive: string
            },
            parentId: string,
            containerType: string,
            instanceId: string,
            nonce: string,
            hardwareCharacteristics: {
              arch: string,
              mem: int,
              rootDisk: int,
              cpuCores: int,
              cpuPower: int,
              tags: []string,
              availabilityZone: string
            },
            addresses: []{
              value: string,
              type: string,
              scope: string,
              spaceName: string
            }
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          machines: []{
            machine: string,
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  addMachinesV2(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#AddMachines
      if (args) {
        params = {};
        params['params'] = [];
        args.params = args.params || [];
        for (let i = 0; i < args.params.length; i++) {
          // github.com/juju/juju/apiserver/params#AddMachineParams
          if (args.params[i]) {
            params['params'][i] = {};
            params['params'][i]['series'] = args.params[i].series;
            // github.com/juju/juju/constraints#Value
            if (args.params[i].constraints) {
              params['params'][i]['constraints'] = {};
              params['params'][i]['constraints']['arch'] = args.params[i].constraints.arch;
              // github.com/juju/juju/instance#ContainerType
              params['params'][i]['constraints']['container'] = args.params[i].constraints.container;
              params['params'][i]['constraints']['cores'] = args.params[i].constraints.cores;
              params['params'][i]['constraints']['cpu-power'] = args.params[i].constraints.cpuPower;
              params['params'][i]['constraints']['mem'] = args.params[i].constraints.mem;
              params['params'][i]['constraints']['root-disk'] = args.params[i].constraints.rootDisk;
              params['params'][i]['constraints']['tags'] = [];
              args.params[i].constraints.tags = args.params[i].constraints.tags || [];
              for (let i2 = 0; i2 < args.params[i].constraints.tags.length; i2++) {
                params['params'][i]['constraints']['tags'][i2] = args.params[i].constraints.tags[i2];
              }
              params['params'][i]['constraints']['instance-type'] = args.params[i].constraints.instanceType;
              params['params'][i]['constraints']['spaces'] = [];
              args.params[i].constraints.spaces = args.params[i].constraints.spaces || [];
              for (let i2 = 0; i2 < args.params[i].constraints.spaces.length; i2++) {
                params['params'][i]['constraints']['spaces'][i2] = args.params[i].constraints.spaces[i2];
              }
              params['params'][i]['constraints']['virt-type'] = args.params[i].constraints.virtType;
            }
            params['params'][i]['jobs'] = [];
            args.params[i].jobs = args.params[i].jobs || [];
            for (let i2 = 0; i2 < args.params[i].jobs.length; i2++) {
              // github.com/juju/juju/state/multiwatcher#MachineJob
              params['params'][i]['jobs'][i2] = args.params[i].jobs[i2];
            }
            params['params'][i]['disks'] = [];
            args.params[i].disks = args.params[i].disks || [];
            for (let i2 = 0; i2 < args.params[i].disks.length; i2++) {
              // github.com/juju/juju/storage#Constraints
              if (args.params[i].disks[i2]) {
                params['params'][i]['disks'][i2] = {};
                params['params'][i]['disks'][i2]['Pool'] = args.params[i].disks[i2].pool;
                params['params'][i]['disks'][i2]['Size'] = args.params[i].disks[i2].size;
                params['params'][i]['disks'][i2]['Count'] = args.params[i].disks[i2].count;
              }
            }
            // github.com/juju/juju/instance#Placement
            if (args.params[i].placement) {
              params['params'][i]['placement'] = {};
              params['params'][i]['placement']['scope'] = args.params[i].placement.scope;
              params['params'][i]['placement']['directive'] = args.params[i].placement.directive;
            }
            params['params'][i]['parent-id'] = args.params[i].parentId;
            // github.com/juju/juju/instance#ContainerType
            params['params'][i]['container-type'] = args.params[i].containerType;
            // github.com/juju/juju/instance#Id
            params['params'][i]['instance-id'] = args.params[i].instanceId;
            params['params'][i]['nonce'] = args.params[i].nonce;
            // github.com/juju/juju/instance#HardwareCharacteristics
            if (args.params[i].hardwareCharacteristics) {
              params['params'][i]['hardware-characteristics'] = {};
              params['params'][i]['hardware-characteristics']['arch'] = args.params[i].hardwareCharacteristics.arch;
              params['params'][i]['hardware-characteristics']['mem'] = args.params[i].hardwareCharacteristics.mem;
              params['params'][i]['hardware-characteristics']['root-disk'] = args.params[i].hardwareCharacteristics.rootDisk;
              params['params'][i]['hardware-characteristics']['cpu-cores'] = args.params[i].hardwareCharacteristics.cpuCores;
              params['params'][i]['hardware-characteristics']['cpu-power'] = args.params[i].hardwareCharacteristics.cpuPower;
              params['params'][i]['hardware-characteristics']['tags'] = [];
              args.params[i].hardwareCharacteristics.tags = args.params[i].hardwareCharacteristics.tags || [];
              for (let i2 = 0; i2 < args.params[i].hardwareCharacteristics.tags.length; i2++) {
                params['params'][i]['hardware-characteristics']['tags'][i2] = args.params[i].hardwareCharacteristics.tags[i2];
              }
              params['params'][i]['hardware-characteristics']['availability-zone'] = args.params[i].hardwareCharacteristics.availabilityZone;
            }
            params['params'][i]['addresses'] = [];
            args.params[i].addresses = args.params[i].addresses || [];
            for (let i2 = 0; i2 < args.params[i].addresses.length; i2++) {
              // github.com/juju/juju/apiserver/params#Address
              if (args.params[i].addresses[i2]) {
                params['params'][i]['addresses'][i2] = {};
                params['params'][i]['addresses'][i2]['value'] = args.params[i].addresses[i2].value;
                params['params'][i]['addresses'][i2]['type'] = args.params[i].addresses[i2].type;
                params['params'][i]['addresses'][i2]['scope'] = args.params[i].addresses[i2].scope;
                params['params'][i]['addresses'][i2]['space-name'] = args.params[i].addresses[i2].spaceName;
              }
            }
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Client',
        request: 'AddMachinesV2',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#AddMachinesResults
        if (resp) {
          result = {};
          result.machines = [];
          resp['machines'] = resp['machines'] || [];
          for (let i = 0; i < resp['machines'].length; i++) {
            // github.com/juju/juju/apiserver/params#AddMachinesResult
            if (resp['machines'][i]) {
              result.machines[i] = {};
              result.machines[i].machine = resp['machines'][i]['machine'];
              // github.com/juju/juju/apiserver/params#Error
              if (resp['machines'][i]['error']) {
                result.machines[i].error = {};
                result.machines[i].error.message = resp['machines'][i]['error']['message'];
                result.machines[i].error.code = resp['machines'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['machines'][i]['error']['info']) {
                  result.machines[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.machines[i].error.info.macaroon = resp['machines'][i]['error']['info']['macaroon'];
                  result.machines[i].error.info.macaroonPath = resp['machines'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    AgentVersion returns the current version that the API server is running.

    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          version: anything
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  agentVersion(callback) {
    return new Promise((resolve, reject) => {
      const params = {};
      // Prepare the request to the Juju API.
      const req = {
        type: 'Client',
        request: 'AgentVersion',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#AgentVersionResult
        if (resp) {
          result = {};
          // github.com/juju/version#Number
          result.version = resp['version'];
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    CACert returns the certificate used to validate the state connection.

    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          result: []int
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  caCert(callback) {
    return new Promise((resolve, reject) => {
      const params = {};
      // Prepare the request to the Juju API.
      const req = {
        type: 'Client',
        request: 'CACert',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#BytesResult
        if (resp) {
          result = {};
          result.result = [];
          resp['result'] = resp['result'] || [];
          for (let i = 0; i < resp['result'].length; i++) {
            result.result[i] = resp['result'][i];
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    DestroyMachines removes a given set of machines.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          machineNames: []string,
          force: bool
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error or null if the operation succeeded.
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  destroyMachines(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#DestroyMachines
      if (args) {
        params = {};
        params['machine-names'] = [];
        args.machineNames = args.machineNames || [];
        for (let i = 0; i < args.machineNames.length; i++) {
          params['machine-names'][i] = args.machineNames[i];
        }
        params['force'] = args.force;
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Client',
        request: 'DestroyMachines',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    FindTools returns a List containing all tools matching the given
    parameters.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          number: anything,
          major: int,
          minor: int,
          arch: string,
          series: string,
          agentstream: string
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          list: []{
            version: anything,
            url: string,
            sha256: string,
            size: int
          },
          error: {
            message: string,
            code: string,
            info: {
              macaroon: anything,
              macaroonPath: string
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  findTools(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#FindToolsParams
      if (args) {
        params = {};
        // github.com/juju/version#Number
        params['number'] = args.number;
        params['major'] = args.major;
        params['minor'] = args.minor;
        params['arch'] = args.arch;
        params['series'] = args.series;
        params['agentstream'] = args.agentstream;
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Client',
        request: 'FindTools',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#FindToolsResult
        if (resp) {
          result = {};
          // github.com/juju/juju/tools#List
          result.list = [];
          resp['list'] = resp['list'] || [];
          for (let i = 0; i < resp['list'].length; i++) {
            // github.com/juju/juju/tools#Tools
            if (resp['list'][i]) {
              result.list[i] = {};
              // github.com/juju/version#Binary
              result.list[i].version = resp['list'][i]['version'];
              result.list[i].url = resp['list'][i]['url'];
              result.list[i].sha256 = resp['list'][i]['sha256'];
              result.list[i].size = resp['list'][i]['size'];
            }
          }
          // github.com/juju/juju/apiserver/params#Error
          if (resp['error']) {
            result.error = {};
            result.error.message = resp['error']['message'];
            result.error.code = resp['error']['code'];
            // github.com/juju/juju/apiserver/params#ErrorInfo
            if (resp['error']['info']) {
              result.error.info = {};
              // gopkg.in/macaroon.v2-unstable#Macaroon
              result.error.info.macaroon = resp['error']['info']['macaroon'];
              result.error.info.macaroonPath = resp['error']['info']['macaroon-path'];
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    FullStatus gives the information needed for juju status over the api

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          patterns: []string
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          model: {
            name: string,
            type: string,
            cloudTag: string,
            region: string,
            version: string,
            availableVersion: string,
            modelStatus: {
              status: string,
              info: string,
              data: map[string]anything,
              since: time,
              kind: string,
              version: string,
              life: string,
              err: anything
            },
            meterStatus: {
              color: string,
              message: string
            },
            sla: string
          },
          machines: map[string]{
            agentStatus: {
              status: string,
              info: string,
              data: map[string]anything,
              since: time,
              kind: string,
              version: string,
              life: string,
              err: anything
            },
            instanceStatus: {
              status: string,
              info: string,
              data: map[string]anything,
              since: time,
              kind: string,
              version: string,
              life: string,
              err: anything
            },
            dnsName: string,
            ipAddresses: []string,
            instanceId: string,
            series: string,
            id: string,
            networkInterfaces: map[string]{
              ipAddresses: []string,
              macAddress: string,
              gateway: string,
              dnsNameservers: []string,
              space: string,
              isUp: bool
            },
            containers: map[string]<github.com/juju/juju/apiserver/params#machinestatus again>,
            constraints: string,
            hardware: string,
            jobs: []string,
            hasVote: bool,
            wantsVote: bool,
            lxdProfiles: map[string]{
              config: map[string]string,
              description: string,
              devices: map[string]map[string]string
            }
          },
          applications: map[string]{
            err: anything,
            charm: string,
            series: string,
            exposed: bool,
            life: string,
            relations: map[string][]string,
            canUpgradeTo: string,
            subordinateTo: []string,
            units: map[string]{
              agentStatus: {
                status: string,
                info: string,
                data: map[string]anything,
                since: time,
                kind: string,
                version: string,
                life: string,
                err: anything
              },
              workloadStatus: {
                status: string,
                info: string,
                data: map[string]anything,
                since: time,
                kind: string,
                version: string,
                life: string,
                err: anything
              },
              workloadVersion: string,
              machine: string,
              openedPorts: []string,
              publicAddress: string,
              charm: string,
              subordinates: map[string]<github.com/juju/juju/apiserver/params#unitstatus again>,
              leader: bool,
              providerId: string,
              address: string
            },
            meterStatuses: map[string]{
              color: string,
              message: string
            },
            status: {
              status: string,
              info: string,
              data: map[string]anything,
              since: time,
              kind: string,
              version: string,
              life: string,
              err: anything
            },
            workloadVersion: string,
            charmVerion: string,
            endpointBindings: map[string]string,
            int: int,
            string: string,
            providerId: string,
            publicAddress: string
          },
          remoteApplications: map[string]{
            err: anything,
            offerUrl: string,
            offerName: string,
            endpoints: []{
              name: string,
              role: string,
              interface: string,
              limit: int
            },
            life: string,
            relations: map[string][]string,
            status: {
              status: string,
              info: string,
              data: map[string]anything,
              since: time,
              kind: string,
              version: string,
              life: string,
              err: anything
            }
          },
          offers: map[string]{
            err: anything,
            offerName: string,
            applicationName: string,
            charm: string,
            endpoints: map[string]{
              name: string,
              role: string,
              interface: string,
              limit: int
            },
            activeConnectedCount: int,
            totalConnectedCount: int
          },
          relations: []{
            id: int,
            key: string,
            interface: string,
            scope: string,
            endpoints: []{
              application: string,
              name: string,
              role: string,
              subordinate: bool
            },
            status: {
              status: string,
              info: string,
              data: map[string]anything,
              since: time,
              kind: string,
              version: string,
              life: string,
              err: anything
            }
          },
          controllerTimestamp: time
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  fullStatus(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#StatusParams
      if (args) {
        params = {};
        params['patterns'] = [];
        args.patterns = args.patterns || [];
        for (let i = 0; i < args.patterns.length; i++) {
          params['patterns'][i] = args.patterns[i];
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Client',
        request: 'FullStatus',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#FullStatus
        if (resp) {
          result = {};
          // github.com/juju/juju/apiserver/params#ModelStatusInfo
          if (resp['model']) {
            result.model = {};
            result.model.name = resp['model']['name'];
            result.model.type = resp['model']['type'];
            result.model.cloudTag = resp['model']['cloud-tag'];
            result.model.region = resp['model']['region'];
            result.model.version = resp['model']['version'];
            result.model.availableVersion = resp['model']['available-version'];
            // github.com/juju/juju/apiserver/params#DetailedStatus
            if (resp['model']['model-status']) {
              result.model.modelStatus = {};
              result.model.modelStatus.status = resp['model']['model-status']['status'];
              result.model.modelStatus.info = resp['model']['model-status']['info'];
              result.model.modelStatus.data = {};
              resp['model']['model-status']['data'] = resp['model']['model-status']['data'] || {};
              for (let k in resp['model']['model-status']['data']) {
                result.model.modelStatus.data[k] = resp['model']['model-status']['data'][k];
              }
              // time#Time
              result.model.modelStatus.since = resp['model']['model-status']['since'];
              result.model.modelStatus.kind = resp['model']['model-status']['kind'];
              result.model.modelStatus.version = resp['model']['model-status']['version'];
              result.model.modelStatus.life = resp['model']['model-status']['life'];
              result.model.modelStatus.err = resp['model']['model-status']['err'];
            }
            // github.com/juju/juju/apiserver/params#MeterStatus
            if (resp['model']['meter-status']) {
              result.model.meterStatus = {};
              result.model.meterStatus.color = resp['model']['meter-status']['color'];
              result.model.meterStatus.message = resp['model']['meter-status']['message'];
            }
            result.model.sla = resp['model']['sla'];
          }
          result.machines = {};
          resp['machines'] = resp['machines'] || {};
          for (let k in resp['machines']) {
            // github.com/juju/juju/apiserver/params#MachineStatus
            if (resp['machines'][k]) {
              result.machines[k] = {};
              // github.com/juju/juju/apiserver/params#DetailedStatus
              if (resp['machines'][k]['agent-status']) {
                result.machines[k].agentStatus = {};
                result.machines[k].agentStatus.status = resp['machines'][k]['agent-status']['status'];
                result.machines[k].agentStatus.info = resp['machines'][k]['agent-status']['info'];
                result.machines[k].agentStatus.data = {};
                resp['machines'][k]['agent-status']['data'] = resp['machines'][k]['agent-status']['data'] || {};
                for (let k2 in resp['machines'][k]['agent-status']['data']) {
                  result.machines[k].agentStatus.data[k2] = resp['machines'][k]['agent-status']['data'][k2];
                }
                // time#Time
                result.machines[k].agentStatus.since = resp['machines'][k]['agent-status']['since'];
                result.machines[k].agentStatus.kind = resp['machines'][k]['agent-status']['kind'];
                result.machines[k].agentStatus.version = resp['machines'][k]['agent-status']['version'];
                result.machines[k].agentStatus.life = resp['machines'][k]['agent-status']['life'];
                result.machines[k].agentStatus.err = resp['machines'][k]['agent-status']['err'];
              }
              // github.com/juju/juju/apiserver/params#DetailedStatus
              if (resp['machines'][k]['instance-status']) {
                result.machines[k].instanceStatus = {};
                result.machines[k].instanceStatus.status = resp['machines'][k]['instance-status']['status'];
                result.machines[k].instanceStatus.info = resp['machines'][k]['instance-status']['info'];
                result.machines[k].instanceStatus.data = {};
                resp['machines'][k]['instance-status']['data'] = resp['machines'][k]['instance-status']['data'] || {};
                for (let k2 in resp['machines'][k]['instance-status']['data']) {
                  result.machines[k].instanceStatus.data[k2] = resp['machines'][k]['instance-status']['data'][k2];
                }
                // time#Time
                result.machines[k].instanceStatus.since = resp['machines'][k]['instance-status']['since'];
                result.machines[k].instanceStatus.kind = resp['machines'][k]['instance-status']['kind'];
                result.machines[k].instanceStatus.version = resp['machines'][k]['instance-status']['version'];
                result.machines[k].instanceStatus.life = resp['machines'][k]['instance-status']['life'];
                result.machines[k].instanceStatus.err = resp['machines'][k]['instance-status']['err'];
              }
              result.machines[k].dnsName = resp['machines'][k]['dns-name'];
              result.machines[k].ipAddresses = [];
              resp['machines'][k]['ip-addresses'] = resp['machines'][k]['ip-addresses'] || [];
              for (let i = 0; i < resp['machines'][k]['ip-addresses'].length; i++) {
                result.machines[k].ipAddresses[i] = resp['machines'][k]['ip-addresses'][i];
              }
              // github.com/juju/juju/instance#Id
              result.machines[k].instanceId = resp['machines'][k]['instance-id'];
              result.machines[k].series = resp['machines'][k]['series'];
              result.machines[k].id = resp['machines'][k]['id'];
              result.machines[k].networkInterfaces = {};
              resp['machines'][k]['network-interfaces'] = resp['machines'][k]['network-interfaces'] || {};
              for (let k2 in resp['machines'][k]['network-interfaces']) {
                // github.com/juju/juju/apiserver/params#NetworkInterface
                if (resp['machines'][k]['network-interfaces'][k2]) {
                  result.machines[k].networkInterfaces[k2] = {};
                  result.machines[k].networkInterfaces[k2].ipAddresses = [];
                  resp['machines'][k]['network-interfaces'][k2]['ip-addresses'] = resp['machines'][k]['network-interfaces'][k2]['ip-addresses'] || [];
                  for (let i = 0; i < resp['machines'][k]['network-interfaces'][k2]['ip-addresses'].length; i++) {
                    result.machines[k].networkInterfaces[k2].ipAddresses[i] = resp['machines'][k]['network-interfaces'][k2]['ip-addresses'][i];
                  }
                  result.machines[k].networkInterfaces[k2].macAddress = resp['machines'][k]['network-interfaces'][k2]['mac-address'];
                  result.machines[k].networkInterfaces[k2].gateway = resp['machines'][k]['network-interfaces'][k2]['gateway'];
                  result.machines[k].networkInterfaces[k2].dnsNameservers = [];
                  resp['machines'][k]['network-interfaces'][k2]['dns-nameservers'] = resp['machines'][k]['network-interfaces'][k2]['dns-nameservers'] || [];
                  for (let i = 0; i < resp['machines'][k]['network-interfaces'][k2]['dns-nameservers'].length; i++) {
                    result.machines[k].networkInterfaces[k2].dnsNameservers[i] = resp['machines'][k]['network-interfaces'][k2]['dns-nameservers'][i];
                  }
                  result.machines[k].networkInterfaces[k2].space = resp['machines'][k]['network-interfaces'][k2]['space'];
                  result.machines[k].networkInterfaces[k2].isUp = resp['machines'][k]['network-interfaces'][k2]['is-up'];
                }
              }
              result.machines[k].containers = {};
              resp['machines'][k]['containers'] = resp['machines'][k]['containers'] || {};
              for (let k2 in resp['machines'][k]['containers']) {
                // github.com/juju/juju/apiserver/params#MachineStatus
                // TODO: handle recursive type referencing github.com/juju/juju/apiserver/params#MachineStatus.
                result.machines[k].containers[k2] = resp['machines'][k]['containers'][k2];
              }
              result.machines[k].constraints = resp['machines'][k]['constraints'];
              result.machines[k].hardware = resp['machines'][k]['hardware'];
              result.machines[k].jobs = [];
              resp['machines'][k]['jobs'] = resp['machines'][k]['jobs'] || [];
              for (let i = 0; i < resp['machines'][k]['jobs'].length; i++) {
                // github.com/juju/juju/state/multiwatcher#MachineJob
                result.machines[k].jobs[i] = resp['machines'][k]['jobs'][i];
              }
              result.machines[k].hasVote = resp['machines'][k]['has-vote'];
              result.machines[k].wantsVote = resp['machines'][k]['wants-vote'];
              result.machines[k].lxdProfiles = {};
              resp['machines'][k]['lxd-profiles'] = resp['machines'][k]['lxd-profiles'] || {};
              for (let k2 in resp['machines'][k]['lxd-profiles']) {
                // github.com/juju/juju/apiserver/params#LXDProfile
                if (resp['machines'][k]['lxd-profiles'][k2]) {
                  result.machines[k].lxdProfiles[k2] = {};
                  result.machines[k].lxdProfiles[k2].config = {};
                  resp['machines'][k]['lxd-profiles'][k2]['config'] = resp['machines'][k]['lxd-profiles'][k2]['config'] || {};
                  for (let k3 in resp['machines'][k]['lxd-profiles'][k2]['config']) {
                    result.machines[k].lxdProfiles[k2].config[k3] = resp['machines'][k]['lxd-profiles'][k2]['config'][k3];
                  }
                  result.machines[k].lxdProfiles[k2].description = resp['machines'][k]['lxd-profiles'][k2]['description'];
                  result.machines[k].lxdProfiles[k2].devices = {};
                  resp['machines'][k]['lxd-profiles'][k2]['devices'] = resp['machines'][k]['lxd-profiles'][k2]['devices'] || {};
                  for (let k3 in resp['machines'][k]['lxd-profiles'][k2]['devices']) {
                    result.machines[k].lxdProfiles[k2].devices[k3] = {};
                    resp['machines'][k]['lxd-profiles'][k2]['devices'][k3] = resp['machines'][k]['lxd-profiles'][k2]['devices'][k3] || {};
                    for (let k4 in resp['machines'][k]['lxd-profiles'][k2]['devices'][k3]) {
                      result.machines[k].lxdProfiles[k2].devices[k3][k4] = resp['machines'][k]['lxd-profiles'][k2]['devices'][k3][k4];
                    }
                  }
                }
              }
            }
          }
          result.applications = {};
          resp['applications'] = resp['applications'] || {};
          for (let k in resp['applications']) {
            // github.com/juju/juju/apiserver/params#ApplicationStatus
            if (resp['applications'][k]) {
              result.applications[k] = {};
              result.applications[k].err = resp['applications'][k]['err'];
              result.applications[k].charm = resp['applications'][k]['charm'];
              result.applications[k].series = resp['applications'][k]['series'];
              result.applications[k].exposed = resp['applications'][k]['exposed'];
              result.applications[k].life = resp['applications'][k]['life'];
              result.applications[k].relations = {};
              resp['applications'][k]['relations'] = resp['applications'][k]['relations'] || {};
              for (let k2 in resp['applications'][k]['relations']) {
                result.applications[k].relations[k2] = [];
                resp['applications'][k]['relations'][k2] = resp['applications'][k]['relations'][k2] || [];
                for (let i = 0; i < resp['applications'][k]['relations'][k2].length; i++) {
                  result.applications[k].relations[k2][i] = resp['applications'][k]['relations'][k2][i];
                }
              }
              result.applications[k].canUpgradeTo = resp['applications'][k]['can-upgrade-to'];
              result.applications[k].subordinateTo = [];
              resp['applications'][k]['subordinate-to'] = resp['applications'][k]['subordinate-to'] || [];
              for (let i = 0; i < resp['applications'][k]['subordinate-to'].length; i++) {
                result.applications[k].subordinateTo[i] = resp['applications'][k]['subordinate-to'][i];
              }
              result.applications[k].units = {};
              resp['applications'][k]['units'] = resp['applications'][k]['units'] || {};
              for (let k2 in resp['applications'][k]['units']) {
                // github.com/juju/juju/apiserver/params#UnitStatus
                if (resp['applications'][k]['units'][k2]) {
                  result.applications[k].units[k2] = {};
                  // github.com/juju/juju/apiserver/params#DetailedStatus
                  if (resp['applications'][k]['units'][k2]['agent-status']) {
                    result.applications[k].units[k2].agentStatus = {};
                    result.applications[k].units[k2].agentStatus.status = resp['applications'][k]['units'][k2]['agent-status']['status'];
                    result.applications[k].units[k2].agentStatus.info = resp['applications'][k]['units'][k2]['agent-status']['info'];
                    result.applications[k].units[k2].agentStatus.data = {};
                    resp['applications'][k]['units'][k2]['agent-status']['data'] = resp['applications'][k]['units'][k2]['agent-status']['data'] || {};
                    for (let k3 in resp['applications'][k]['units'][k2]['agent-status']['data']) {
                      result.applications[k].units[k2].agentStatus.data[k3] = resp['applications'][k]['units'][k2]['agent-status']['data'][k3];
                    }
                    // time#Time
                    result.applications[k].units[k2].agentStatus.since = resp['applications'][k]['units'][k2]['agent-status']['since'];
                    result.applications[k].units[k2].agentStatus.kind = resp['applications'][k]['units'][k2]['agent-status']['kind'];
                    result.applications[k].units[k2].agentStatus.version = resp['applications'][k]['units'][k2]['agent-status']['version'];
                    result.applications[k].units[k2].agentStatus.life = resp['applications'][k]['units'][k2]['agent-status']['life'];
                    result.applications[k].units[k2].agentStatus.err = resp['applications'][k]['units'][k2]['agent-status']['err'];
                  }
                  // github.com/juju/juju/apiserver/params#DetailedStatus
                  if (resp['applications'][k]['units'][k2]['workload-status']) {
                    result.applications[k].units[k2].workloadStatus = {};
                    result.applications[k].units[k2].workloadStatus.status = resp['applications'][k]['units'][k2]['workload-status']['status'];
                    result.applications[k].units[k2].workloadStatus.info = resp['applications'][k]['units'][k2]['workload-status']['info'];
                    result.applications[k].units[k2].workloadStatus.data = {};
                    resp['applications'][k]['units'][k2]['workload-status']['data'] = resp['applications'][k]['units'][k2]['workload-status']['data'] || {};
                    for (let k3 in resp['applications'][k]['units'][k2]['workload-status']['data']) {
                      result.applications[k].units[k2].workloadStatus.data[k3] = resp['applications'][k]['units'][k2]['workload-status']['data'][k3];
                    }
                    // time#Time
                    result.applications[k].units[k2].workloadStatus.since = resp['applications'][k]['units'][k2]['workload-status']['since'];
                    result.applications[k].units[k2].workloadStatus.kind = resp['applications'][k]['units'][k2]['workload-status']['kind'];
                    result.applications[k].units[k2].workloadStatus.version = resp['applications'][k]['units'][k2]['workload-status']['version'];
                    result.applications[k].units[k2].workloadStatus.life = resp['applications'][k]['units'][k2]['workload-status']['life'];
                    result.applications[k].units[k2].workloadStatus.err = resp['applications'][k]['units'][k2]['workload-status']['err'];
                  }
                  result.applications[k].units[k2].workloadVersion = resp['applications'][k]['units'][k2]['workload-version'];
                  result.applications[k].units[k2].machine = resp['applications'][k]['units'][k2]['machine'];
                  result.applications[k].units[k2].openedPorts = [];
                  resp['applications'][k]['units'][k2]['opened-ports'] = resp['applications'][k]['units'][k2]['opened-ports'] || [];
                  for (let i = 0; i < resp['applications'][k]['units'][k2]['opened-ports'].length; i++) {
                    result.applications[k].units[k2].openedPorts[i] = resp['applications'][k]['units'][k2]['opened-ports'][i];
                  }
                  result.applications[k].units[k2].publicAddress = resp['applications'][k]['units'][k2]['public-address'];
                  result.applications[k].units[k2].charm = resp['applications'][k]['units'][k2]['charm'];
                  result.applications[k].units[k2].subordinates = {};
                  resp['applications'][k]['units'][k2]['subordinates'] = resp['applications'][k]['units'][k2]['subordinates'] || {};
                  for (let k3 in resp['applications'][k]['units'][k2]['subordinates']) {
                    // github.com/juju/juju/apiserver/params#UnitStatus
                    // TODO: handle recursive type referencing github.com/juju/juju/apiserver/params#UnitStatus.
                    result.applications[k].units[k2].subordinates[k3] = resp['applications'][k]['units'][k2]['subordinates'][k3];
                  }
                  result.applications[k].units[k2].leader = resp['applications'][k]['units'][k2]['leader'];
                  result.applications[k].units[k2].providerId = resp['applications'][k]['units'][k2]['provider-id'];
                  result.applications[k].units[k2].address = resp['applications'][k]['units'][k2]['address'];
                }
              }
              result.applications[k].meterStatuses = {};
              resp['applications'][k]['meter-statuses'] = resp['applications'][k]['meter-statuses'] || {};
              for (let k2 in resp['applications'][k]['meter-statuses']) {
                // github.com/juju/juju/apiserver/params#MeterStatus
                if (resp['applications'][k]['meter-statuses'][k2]) {
                  result.applications[k].meterStatuses[k2] = {};
                  result.applications[k].meterStatuses[k2].color = resp['applications'][k]['meter-statuses'][k2]['color'];
                  result.applications[k].meterStatuses[k2].message = resp['applications'][k]['meter-statuses'][k2]['message'];
                }
              }
              // github.com/juju/juju/apiserver/params#DetailedStatus
              if (resp['applications'][k]['status']) {
                result.applications[k].status = {};
                result.applications[k].status.status = resp['applications'][k]['status']['status'];
                result.applications[k].status.info = resp['applications'][k]['status']['info'];
                result.applications[k].status.data = {};
                resp['applications'][k]['status']['data'] = resp['applications'][k]['status']['data'] || {};
                for (let k2 in resp['applications'][k]['status']['data']) {
                  result.applications[k].status.data[k2] = resp['applications'][k]['status']['data'][k2];
                }
                // time#Time
                result.applications[k].status.since = resp['applications'][k]['status']['since'];
                result.applications[k].status.kind = resp['applications'][k]['status']['kind'];
                result.applications[k].status.version = resp['applications'][k]['status']['version'];
                result.applications[k].status.life = resp['applications'][k]['status']['life'];
                result.applications[k].status.err = resp['applications'][k]['status']['err'];
              }
              result.applications[k].workloadVersion = resp['applications'][k]['workload-version'];
              result.applications[k].charmVerion = resp['applications'][k]['charm-verion'];
              result.applications[k].endpointBindings = {};
              resp['applications'][k]['endpoint-bindings'] = resp['applications'][k]['endpoint-bindings'] || {};
              for (let k2 in resp['applications'][k]['endpoint-bindings']) {
                result.applications[k].endpointBindings[k2] = resp['applications'][k]['endpoint-bindings'][k2];
              }
              result.applications[k].int = resp['applications'][k]['int'];
              result.applications[k].string = resp['applications'][k]['string'];
              result.applications[k].providerId = resp['applications'][k]['provider-id'];
              result.applications[k].publicAddress = resp['applications'][k]['public-address'];
            }
          }
          result.remoteApplications = {};
          resp['remote-applications'] = resp['remote-applications'] || {};
          for (let k in resp['remote-applications']) {
            // github.com/juju/juju/apiserver/params#RemoteApplicationStatus
            if (resp['remote-applications'][k]) {
              result.remoteApplications[k] = {};
              result.remoteApplications[k].err = resp['remote-applications'][k]['err'];
              result.remoteApplications[k].offerUrl = resp['remote-applications'][k]['offer-url'];
              result.remoteApplications[k].offerName = resp['remote-applications'][k]['offer-name'];
              result.remoteApplications[k].endpoints = [];
              resp['remote-applications'][k]['endpoints'] = resp['remote-applications'][k]['endpoints'] || [];
              for (let i = 0; i < resp['remote-applications'][k]['endpoints'].length; i++) {
                // github.com/juju/juju/apiserver/params#RemoteEndpoint
                if (resp['remote-applications'][k]['endpoints'][i]) {
                  result.remoteApplications[k].endpoints[i] = {};
                  result.remoteApplications[k].endpoints[i].name = resp['remote-applications'][k]['endpoints'][i]['name'];
                  // gopkg.in/juju/charm.v6#RelationRole
                  result.remoteApplications[k].endpoints[i].role = resp['remote-applications'][k]['endpoints'][i]['role'];
                  result.remoteApplications[k].endpoints[i].interface = resp['remote-applications'][k]['endpoints'][i]['interface'];
                  result.remoteApplications[k].endpoints[i].limit = resp['remote-applications'][k]['endpoints'][i]['limit'];
                }
              }
              result.remoteApplications[k].life = resp['remote-applications'][k]['life'];
              result.remoteApplications[k].relations = {};
              resp['remote-applications'][k]['relations'] = resp['remote-applications'][k]['relations'] || {};
              for (let k2 in resp['remote-applications'][k]['relations']) {
                result.remoteApplications[k].relations[k2] = [];
                resp['remote-applications'][k]['relations'][k2] = resp['remote-applications'][k]['relations'][k2] || [];
                for (let i = 0; i < resp['remote-applications'][k]['relations'][k2].length; i++) {
                  result.remoteApplications[k].relations[k2][i] = resp['remote-applications'][k]['relations'][k2][i];
                }
              }
              // github.com/juju/juju/apiserver/params#DetailedStatus
              if (resp['remote-applications'][k]['status']) {
                result.remoteApplications[k].status = {};
                result.remoteApplications[k].status.status = resp['remote-applications'][k]['status']['status'];
                result.remoteApplications[k].status.info = resp['remote-applications'][k]['status']['info'];
                result.remoteApplications[k].status.data = {};
                resp['remote-applications'][k]['status']['data'] = resp['remote-applications'][k]['status']['data'] || {};
                for (let k2 in resp['remote-applications'][k]['status']['data']) {
                  result.remoteApplications[k].status.data[k2] = resp['remote-applications'][k]['status']['data'][k2];
                }
                // time#Time
                result.remoteApplications[k].status.since = resp['remote-applications'][k]['status']['since'];
                result.remoteApplications[k].status.kind = resp['remote-applications'][k]['status']['kind'];
                result.remoteApplications[k].status.version = resp['remote-applications'][k]['status']['version'];
                result.remoteApplications[k].status.life = resp['remote-applications'][k]['status']['life'];
                result.remoteApplications[k].status.err = resp['remote-applications'][k]['status']['err'];
              }
            }
          }
          result.offers = {};
          resp['offers'] = resp['offers'] || {};
          for (let k in resp['offers']) {
            // github.com/juju/juju/apiserver/params#ApplicationOfferStatus
            if (resp['offers'][k]) {
              result.offers[k] = {};
              result.offers[k].err = resp['offers'][k]['err'];
              result.offers[k].offerName = resp['offers'][k]['offer-name'];
              result.offers[k].applicationName = resp['offers'][k]['application-name'];
              result.offers[k].charm = resp['offers'][k]['charm'];
              result.offers[k].endpoints = {};
              resp['offers'][k]['endpoints'] = resp['offers'][k]['endpoints'] || {};
              for (let k2 in resp['offers'][k]['endpoints']) {
                // github.com/juju/juju/apiserver/params#RemoteEndpoint
                if (resp['offers'][k]['endpoints'][k2]) {
                  result.offers[k].endpoints[k2] = {};
                  result.offers[k].endpoints[k2].name = resp['offers'][k]['endpoints'][k2]['name'];
                  // gopkg.in/juju/charm.v6#RelationRole
                  result.offers[k].endpoints[k2].role = resp['offers'][k]['endpoints'][k2]['role'];
                  result.offers[k].endpoints[k2].interface = resp['offers'][k]['endpoints'][k2]['interface'];
                  result.offers[k].endpoints[k2].limit = resp['offers'][k]['endpoints'][k2]['limit'];
                }
              }
              result.offers[k].activeConnectedCount = resp['offers'][k]['active-connected-count'];
              result.offers[k].totalConnectedCount = resp['offers'][k]['total-connected-count'];
            }
          }
          result.relations = [];
          resp['relations'] = resp['relations'] || [];
          for (let i = 0; i < resp['relations'].length; i++) {
            // github.com/juju/juju/apiserver/params#RelationStatus
            if (resp['relations'][i]) {
              result.relations[i] = {};
              result.relations[i].id = resp['relations'][i]['id'];
              result.relations[i].key = resp['relations'][i]['key'];
              result.relations[i].interface = resp['relations'][i]['interface'];
              result.relations[i].scope = resp['relations'][i]['scope'];
              result.relations[i].endpoints = [];
              resp['relations'][i]['endpoints'] = resp['relations'][i]['endpoints'] || [];
              for (let i2 = 0; i2 < resp['relations'][i]['endpoints'].length; i2++) {
                // github.com/juju/juju/apiserver/params#EndpointStatus
                if (resp['relations'][i]['endpoints'][i2]) {
                  result.relations[i].endpoints[i2] = {};
                  result.relations[i].endpoints[i2].application = resp['relations'][i]['endpoints'][i2]['application'];
                  result.relations[i].endpoints[i2].name = resp['relations'][i]['endpoints'][i2]['name'];
                  result.relations[i].endpoints[i2].role = resp['relations'][i]['endpoints'][i2]['role'];
                  result.relations[i].endpoints[i2].subordinate = resp['relations'][i]['endpoints'][i2]['subordinate'];
                }
              }
              // github.com/juju/juju/apiserver/params#DetailedStatus
              if (resp['relations'][i]['status']) {
                result.relations[i].status = {};
                result.relations[i].status.status = resp['relations'][i]['status']['status'];
                result.relations[i].status.info = resp['relations'][i]['status']['info'];
                result.relations[i].status.data = {};
                resp['relations'][i]['status']['data'] = resp['relations'][i]['status']['data'] || {};
                for (let k in resp['relations'][i]['status']['data']) {
                  result.relations[i].status.data[k] = resp['relations'][i]['status']['data'][k];
                }
                // time#Time
                result.relations[i].status.since = resp['relations'][i]['status']['since'];
                result.relations[i].status.kind = resp['relations'][i]['status']['kind'];
                result.relations[i].status.version = resp['relations'][i]['status']['version'];
                result.relations[i].status.life = resp['relations'][i]['status']['life'];
                result.relations[i].status.err = resp['relations'][i]['status']['err'];
              }
            }
          }
          // time#Time
          result.controllerTimestamp = resp['controller-timestamp'];
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    GetBundleChanges returns the list of changes required to deploy the given
    bundle data. The changes are sorted by requirements, so that they can
    be applied in order. This call is deprecated, clients should use the
    GetChanges endpoint on the Bundle facade. Note: any new feature in the
    future like devices will never be supported here.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          yaml: string,
          bundleurl: string
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          changes: []{
            id: string,
            method: string,
            args: []anything,
            requires: []string
          },
          errors: []string
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  getBundleChanges(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#BundleChangesParams
      if (args) {
        params = {};
        params['yaml'] = args.yaml;
        params['bundleURL'] = args.bundleurl;
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Client',
        request: 'GetBundleChanges',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#BundleChangesResults
        if (resp) {
          result = {};
          result.changes = [];
          resp['changes'] = resp['changes'] || [];
          for (let i = 0; i < resp['changes'].length; i++) {
            // github.com/juju/juju/apiserver/params#BundleChange
            if (resp['changes'][i]) {
              result.changes[i] = {};
              result.changes[i].id = resp['changes'][i]['id'];
              result.changes[i].method = resp['changes'][i]['method'];
              result.changes[i].args = [];
              resp['changes'][i]['args'] = resp['changes'][i]['args'] || [];
              for (let i2 = 0; i2 < resp['changes'][i]['args'].length; i2++) {
                result.changes[i].args[i2] = resp['changes'][i]['args'][i2];
              }
              result.changes[i].requires = [];
              resp['changes'][i]['requires'] = resp['changes'][i]['requires'] || [];
              for (let i2 = 0; i2 < resp['changes'][i]['requires'].length; i2++) {
                result.changes[i].requires[i2] = resp['changes'][i]['requires'][i2];
              }
            }
          }
          result.errors = [];
          resp['errors'] = resp['errors'] || [];
          for (let i = 0; i < resp['errors'].length; i++) {
            result.errors[i] = resp['errors'][i];
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    GetModelConstraints returns the constraints for the model.

    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          constraints: {
            arch: string,
            container: string,
            cores: int,
            cpuPower: int,
            mem: int,
            rootDisk: int,
            tags: []string,
            instanceType: string,
            spaces: []string,
            virtType: string
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  getModelConstraints(callback) {
    return new Promise((resolve, reject) => {
      const params = {};
      // Prepare the request to the Juju API.
      const req = {
        type: 'Client',
        request: 'GetModelConstraints',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#GetConstraintsResults
        if (resp) {
          result = {};
          // github.com/juju/juju/constraints#Value
          if (resp['constraints']) {
            result.constraints = {};
            result.constraints.arch = resp['constraints']['arch'];
            // github.com/juju/juju/instance#ContainerType
            result.constraints.container = resp['constraints']['container'];
            result.constraints.cores = resp['constraints']['cores'];
            result.constraints.cpuPower = resp['constraints']['cpu-power'];
            result.constraints.mem = resp['constraints']['mem'];
            result.constraints.rootDisk = resp['constraints']['root-disk'];
            result.constraints.tags = [];
            resp['constraints']['tags'] = resp['constraints']['tags'] || [];
            for (let i = 0; i < resp['constraints']['tags'].length; i++) {
              result.constraints.tags[i] = resp['constraints']['tags'][i];
            }
            result.constraints.instanceType = resp['constraints']['instance-type'];
            result.constraints.spaces = [];
            resp['constraints']['spaces'] = resp['constraints']['spaces'] || [];
            for (let i = 0; i < resp['constraints']['spaces'].length; i++) {
              result.constraints.spaces[i] = resp['constraints']['spaces'][i];
            }
            result.constraints.virtType = resp['constraints']['virt-type'];
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    InjectMachines injects a machine into state with provisioned status.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          params: []{
            series: string,
            constraints: {
              arch: string,
              container: string,
              cores: int,
              cpuPower: int,
              mem: int,
              rootDisk: int,
              tags: []string,
              instanceType: string,
              spaces: []string,
              virtType: string
            },
            jobs: []string,
            disks: []{
              pool: string,
              size: int,
              count: int
            },
            placement: {
              scope: string,
              directive: string
            },
            parentId: string,
            containerType: string,
            instanceId: string,
            nonce: string,
            hardwareCharacteristics: {
              arch: string,
              mem: int,
              rootDisk: int,
              cpuCores: int,
              cpuPower: int,
              tags: []string,
              availabilityZone: string
            },
            addresses: []{
              value: string,
              type: string,
              scope: string,
              spaceName: string
            }
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          machines: []{
            machine: string,
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  injectMachines(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#AddMachines
      if (args) {
        params = {};
        params['params'] = [];
        args.params = args.params || [];
        for (let i = 0; i < args.params.length; i++) {
          // github.com/juju/juju/apiserver/params#AddMachineParams
          if (args.params[i]) {
            params['params'][i] = {};
            params['params'][i]['series'] = args.params[i].series;
            // github.com/juju/juju/constraints#Value
            if (args.params[i].constraints) {
              params['params'][i]['constraints'] = {};
              params['params'][i]['constraints']['arch'] = args.params[i].constraints.arch;
              // github.com/juju/juju/instance#ContainerType
              params['params'][i]['constraints']['container'] = args.params[i].constraints.container;
              params['params'][i]['constraints']['cores'] = args.params[i].constraints.cores;
              params['params'][i]['constraints']['cpu-power'] = args.params[i].constraints.cpuPower;
              params['params'][i]['constraints']['mem'] = args.params[i].constraints.mem;
              params['params'][i]['constraints']['root-disk'] = args.params[i].constraints.rootDisk;
              params['params'][i]['constraints']['tags'] = [];
              args.params[i].constraints.tags = args.params[i].constraints.tags || [];
              for (let i2 = 0; i2 < args.params[i].constraints.tags.length; i2++) {
                params['params'][i]['constraints']['tags'][i2] = args.params[i].constraints.tags[i2];
              }
              params['params'][i]['constraints']['instance-type'] = args.params[i].constraints.instanceType;
              params['params'][i]['constraints']['spaces'] = [];
              args.params[i].constraints.spaces = args.params[i].constraints.spaces || [];
              for (let i2 = 0; i2 < args.params[i].constraints.spaces.length; i2++) {
                params['params'][i]['constraints']['spaces'][i2] = args.params[i].constraints.spaces[i2];
              }
              params['params'][i]['constraints']['virt-type'] = args.params[i].constraints.virtType;
            }
            params['params'][i]['jobs'] = [];
            args.params[i].jobs = args.params[i].jobs || [];
            for (let i2 = 0; i2 < args.params[i].jobs.length; i2++) {
              // github.com/juju/juju/state/multiwatcher#MachineJob
              params['params'][i]['jobs'][i2] = args.params[i].jobs[i2];
            }
            params['params'][i]['disks'] = [];
            args.params[i].disks = args.params[i].disks || [];
            for (let i2 = 0; i2 < args.params[i].disks.length; i2++) {
              // github.com/juju/juju/storage#Constraints
              if (args.params[i].disks[i2]) {
                params['params'][i]['disks'][i2] = {};
                params['params'][i]['disks'][i2]['Pool'] = args.params[i].disks[i2].pool;
                params['params'][i]['disks'][i2]['Size'] = args.params[i].disks[i2].size;
                params['params'][i]['disks'][i2]['Count'] = args.params[i].disks[i2].count;
              }
            }
            // github.com/juju/juju/instance#Placement
            if (args.params[i].placement) {
              params['params'][i]['placement'] = {};
              params['params'][i]['placement']['scope'] = args.params[i].placement.scope;
              params['params'][i]['placement']['directive'] = args.params[i].placement.directive;
            }
            params['params'][i]['parent-id'] = args.params[i].parentId;
            // github.com/juju/juju/instance#ContainerType
            params['params'][i]['container-type'] = args.params[i].containerType;
            // github.com/juju/juju/instance#Id
            params['params'][i]['instance-id'] = args.params[i].instanceId;
            params['params'][i]['nonce'] = args.params[i].nonce;
            // github.com/juju/juju/instance#HardwareCharacteristics
            if (args.params[i].hardwareCharacteristics) {
              params['params'][i]['hardware-characteristics'] = {};
              params['params'][i]['hardware-characteristics']['arch'] = args.params[i].hardwareCharacteristics.arch;
              params['params'][i]['hardware-characteristics']['mem'] = args.params[i].hardwareCharacteristics.mem;
              params['params'][i]['hardware-characteristics']['root-disk'] = args.params[i].hardwareCharacteristics.rootDisk;
              params['params'][i]['hardware-characteristics']['cpu-cores'] = args.params[i].hardwareCharacteristics.cpuCores;
              params['params'][i]['hardware-characteristics']['cpu-power'] = args.params[i].hardwareCharacteristics.cpuPower;
              params['params'][i]['hardware-characteristics']['tags'] = [];
              args.params[i].hardwareCharacteristics.tags = args.params[i].hardwareCharacteristics.tags || [];
              for (let i2 = 0; i2 < args.params[i].hardwareCharacteristics.tags.length; i2++) {
                params['params'][i]['hardware-characteristics']['tags'][i2] = args.params[i].hardwareCharacteristics.tags[i2];
              }
              params['params'][i]['hardware-characteristics']['availability-zone'] = args.params[i].hardwareCharacteristics.availabilityZone;
            }
            params['params'][i]['addresses'] = [];
            args.params[i].addresses = args.params[i].addresses || [];
            for (let i2 = 0; i2 < args.params[i].addresses.length; i2++) {
              // github.com/juju/juju/apiserver/params#Address
              if (args.params[i].addresses[i2]) {
                params['params'][i]['addresses'][i2] = {};
                params['params'][i]['addresses'][i2]['value'] = args.params[i].addresses[i2].value;
                params['params'][i]['addresses'][i2]['type'] = args.params[i].addresses[i2].type;
                params['params'][i]['addresses'][i2]['scope'] = args.params[i].addresses[i2].scope;
                params['params'][i]['addresses'][i2]['space-name'] = args.params[i].addresses[i2].spaceName;
              }
            }
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Client',
        request: 'InjectMachines',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#AddMachinesResults
        if (resp) {
          result = {};
          result.machines = [];
          resp['machines'] = resp['machines'] || [];
          for (let i = 0; i < resp['machines'].length; i++) {
            // github.com/juju/juju/apiserver/params#AddMachinesResult
            if (resp['machines'][i]) {
              result.machines[i] = {};
              result.machines[i].machine = resp['machines'][i]['machine'];
              // github.com/juju/juju/apiserver/params#Error
              if (resp['machines'][i]['error']) {
                result.machines[i].error = {};
                result.machines[i].error.message = resp['machines'][i]['error']['message'];
                result.machines[i].error.code = resp['machines'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['machines'][i]['error']['info']) {
                  result.machines[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.machines[i].error.info.macaroon = resp['machines'][i]['error']['info']['macaroon'];
                  result.machines[i].error.info.macaroonPath = resp['machines'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    ModelGet implements the server-side part of the model-config CLI command.

    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          config: map[string]{
            value: anything,
            source: string
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  modelGet(callback) {
    return new Promise((resolve, reject) => {
      const params = {};
      // Prepare the request to the Juju API.
      const req = {
        type: 'Client',
        request: 'ModelGet',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ModelConfigResults
        if (resp) {
          result = {};
          result.config = {};
          resp['config'] = resp['config'] || {};
          for (let k in resp['config']) {
            // github.com/juju/juju/apiserver/params#ConfigValue
            if (resp['config'][k]) {
              result.config[k] = {};
              result.config[k].value = resp['config'][k]['value'];
              result.config[k].source = resp['config'][k]['source'];
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    ModelInfo returns information about the current model.

    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          name: string,
          type: string,
          uuid: string,
          controllerUuid: string,
          providerType: string,
          defaultSeries: string,
          cloudTag: string,
          cloudRegion: string,
          cloudCredentialTag: string,
          ownerTag: string,
          life: string,
          status: {
            status: string,
            info: string,
            data: map[string]anything,
            since: time
          },
          users: []{
            user: string,
            displayName: string,
            lastConnection: time,
            access: string
          },
          machines: []{
            id: string,
            hardware: {
              arch: string,
              mem: int,
              rootDisk: int,
              cores: int,
              cpuPower: int,
              tags: []string,
              availabilityZone: string
            },
            instanceId: string,
            status: string,
            hasVote: bool,
            wantsVote: bool
          },
          migration: {
            status: string,
            start: time,
            end: time
          },
          sla: {
            level: string,
            owner: string
          },
          agentVersion: anything
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  modelInfo(callback) {
    return new Promise((resolve, reject) => {
      const params = {};
      // Prepare the request to the Juju API.
      const req = {
        type: 'Client',
        request: 'ModelInfo',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ModelInfo
        if (resp) {
          result = {};
          result.name = resp['name'];
          result.type = resp['type'];
          result.uuid = resp['uuid'];
          result.controllerUuid = resp['controller-uuid'];
          result.providerType = resp['provider-type'];
          result.defaultSeries = resp['default-series'];
          result.cloudTag = resp['cloud-tag'];
          result.cloudRegion = resp['cloud-region'];
          result.cloudCredentialTag = resp['cloud-credential-tag'];
          result.ownerTag = resp['owner-tag'];
          // github.com/juju/juju/apiserver/params#Life
          result.life = resp['life'];
          // github.com/juju/juju/apiserver/params#EntityStatus
          if (resp['status']) {
            result.status = {};
            // github.com/juju/juju/core/status#Status
            result.status.status = resp['status']['status'];
            result.status.info = resp['status']['info'];
            result.status.data = {};
            resp['status']['data'] = resp['status']['data'] || {};
            for (let k in resp['status']['data']) {
              result.status.data[k] = resp['status']['data'][k];
            }
            // time#Time
            result.status.since = resp['status']['since'];
          }
          result.users = [];
          resp['users'] = resp['users'] || [];
          for (let i = 0; i < resp['users'].length; i++) {
            // github.com/juju/juju/apiserver/params#ModelUserInfo
            if (resp['users'][i]) {
              result.users[i] = {};
              result.users[i].user = resp['users'][i]['user'];
              result.users[i].displayName = resp['users'][i]['display-name'];
              // time#Time
              result.users[i].lastConnection = resp['users'][i]['last-connection'];
              // github.com/juju/juju/apiserver/params#UserAccessPermission
              result.users[i].access = resp['users'][i]['access'];
            }
          }
          result.machines = [];
          resp['machines'] = resp['machines'] || [];
          for (let i = 0; i < resp['machines'].length; i++) {
            // github.com/juju/juju/apiserver/params#ModelMachineInfo
            if (resp['machines'][i]) {
              result.machines[i] = {};
              result.machines[i].id = resp['machines'][i]['id'];
              // github.com/juju/juju/apiserver/params#MachineHardware
              if (resp['machines'][i]['hardware']) {
                result.machines[i].hardware = {};
                result.machines[i].hardware.arch = resp['machines'][i]['hardware']['arch'];
                result.machines[i].hardware.mem = resp['machines'][i]['hardware']['mem'];
                result.machines[i].hardware.rootDisk = resp['machines'][i]['hardware']['root-disk'];
                result.machines[i].hardware.cores = resp['machines'][i]['hardware']['cores'];
                result.machines[i].hardware.cpuPower = resp['machines'][i]['hardware']['cpu-power'];
                result.machines[i].hardware.tags = [];
                resp['machines'][i]['hardware']['tags'] = resp['machines'][i]['hardware']['tags'] || [];
                for (let i2 = 0; i2 < resp['machines'][i]['hardware']['tags'].length; i2++) {
                  result.machines[i].hardware.tags[i2] = resp['machines'][i]['hardware']['tags'][i2];
                }
                result.machines[i].hardware.availabilityZone = resp['machines'][i]['hardware']['availability-zone'];
              }
              result.machines[i].instanceId = resp['machines'][i]['instance-id'];
              result.machines[i].status = resp['machines'][i]['status'];
              result.machines[i].hasVote = resp['machines'][i]['has-vote'];
              result.machines[i].wantsVote = resp['machines'][i]['wants-vote'];
            }
          }
          // github.com/juju/juju/apiserver/params#ModelMigrationStatus
          if (resp['migration']) {
            result.migration = {};
            result.migration.status = resp['migration']['status'];
            // time#Time
            result.migration.start = resp['migration']['start'];
            // time#Time
            result.migration.end = resp['migration']['end'];
          }
          // github.com/juju/juju/apiserver/params#ModelSLAInfo
          if (resp['sla']) {
            result.sla = {};
            result.sla.level = resp['sla']['level'];
            result.sla.owner = resp['sla']['owner'];
          }
          // github.com/juju/version#Number
          result.agentVersion = resp['agent-version'];
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    ModelSet implements the server-side part of the set-model-config CLI
    command.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          config: map[string]anything
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error or null if the operation succeeded.
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  modelSet(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#ModelSet
      if (args) {
        params = {};
        params['config'] = {};
        args.config = args.config || {};
        for (let k in args.config) {
          params['config'][k] = args.config[k];
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Client',
        request: 'ModelSet',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    ModelUnset implements the server-side part of the set-model-config CLI
    command.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          keys: []string
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error or null if the operation succeeded.
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  modelUnset(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#ModelUnset
      if (args) {
        params = {};
        params['keys'] = [];
        args.keys = args.keys || [];
        for (let i = 0; i < args.keys.length; i++) {
          params['keys'][i] = args.keys[i];
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Client',
        request: 'ModelUnset',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    ModelUserInfo returns information on all users in the model.

    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            result: {
              user: string,
              displayName: string,
              lastConnection: time,
              access: string
            },
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  modelUserInfo(callback) {
    return new Promise((resolve, reject) => {
      const params = {};
      // Prepare the request to the Juju API.
      const req = {
        type: 'Client',
        request: 'ModelUserInfo',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ModelUserInfoResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#ModelUserInfoResult
            if (resp['results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/apiserver/params#ModelUserInfo
              if (resp['results'][i]['result']) {
                result.results[i].result = {};
                result.results[i].result.user = resp['results'][i]['result']['user'];
                result.results[i].result.displayName = resp['results'][i]['result']['display-name'];
                // time#Time
                result.results[i].result.lastConnection = resp['results'][i]['result']['last-connection'];
                // github.com/juju/juju/apiserver/params#UserAccessPermission
                result.results[i].result.access = resp['results'][i]['result']['access'];
              }
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    PrivateAddress implements the server side of Client.PrivateAddress.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          target: string
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          privateAddress: string
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  privateAddress(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#PrivateAddress
      if (args) {
        params = {};
        params['target'] = args.target;
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Client',
        request: 'PrivateAddress',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#PrivateAddressResults
        if (resp) {
          result = {};
          result.privateAddress = resp['private-address'];
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    ProvisioningScript returns a shell script that, when run, provisions a
    machine agent on the machine executing the script.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          machineId: string,
          nonce: string,
          dataDir: string,
          disablePackageCommands: bool
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          script: string
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  provisioningScript(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#ProvisioningScriptParams
      if (args) {
        params = {};
        params['machine-id'] = args.machineId;
        params['nonce'] = args.nonce;
        params['data-dir'] = args.dataDir;
        params['disable-package-commands'] = args.disablePackageCommands;
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Client',
        request: 'ProvisioningScript',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ProvisioningScriptResult
        if (resp) {
          result = {};
          result.script = resp['script'];
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    PublicAddress implements the server side of Client.PublicAddress.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          target: string
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          publicAddress: string
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  publicAddress(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#PublicAddress
      if (args) {
        params = {};
        params['target'] = args.target;
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Client',
        request: 'PublicAddress',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#PublicAddressResults
        if (resp) {
          result = {};
          result.publicAddress = resp['public-address'];
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    ResolveCharm resolves the best available charm URLs with series, for charm
    locations without a series specified.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          references: []string
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          urls: []{
            url: string,
            error: string
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  resolveCharms(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#ResolveCharms
      if (args) {
        params = {};
        params['references'] = [];
        args.references = args.references || [];
        for (let i = 0; i < args.references.length; i++) {
          params['references'][i] = args.references[i];
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Client',
        request: 'ResolveCharms',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ResolveCharmResults
        if (resp) {
          result = {};
          result.urls = [];
          resp['urls'] = resp['urls'] || [];
          for (let i = 0; i < resp['urls'].length; i++) {
            // github.com/juju/juju/apiserver/params#ResolveCharmResult
            if (resp['urls'][i]) {
              result.urls[i] = {};
              result.urls[i].url = resp['urls'][i]['url'];
              result.urls[i].error = resp['urls'][i]['error'];
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    Resolved implements the server side of Client.Resolved.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          unitName: string,
          retry: bool
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error or null if the operation succeeded.
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  resolved(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#Resolved
      if (args) {
        params = {};
        params['unit-name'] = args.unitName;
        params['retry'] = args.retry;
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Client',
        request: 'Resolved',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    RetryProvisioning marks a provisioning error as transient on the machines.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          entities: []{
            tag: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  retryProvisioning(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#Entities
      if (args) {
        params = {};
        params['entities'] = [];
        args.entities = args.entities || [];
        for (let i = 0; i < args.entities.length; i++) {
          // github.com/juju/juju/apiserver/params#Entity
          if (args.entities[i]) {
            params['entities'][i] = {};
            params['entities'][i]['tag'] = args.entities[i].tag;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Client',
        request: 'RetryProvisioning',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ErrorResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#ErrorResult
            if (resp['results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    SLALevel returns the current sla level for the model.

    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          error: {
            message: string,
            code: string,
            info: {
              macaroon: anything,
              macaroonPath: string
            }
          },
          result: string
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  slaLevel(callback) {
    return new Promise((resolve, reject) => {
      const params = {};
      // Prepare the request to the Juju API.
      const req = {
        type: 'Client',
        request: 'SLALevel',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#StringResult
        if (resp) {
          result = {};
          // github.com/juju/juju/apiserver/params#Error
          if (resp['error']) {
            result.error = {};
            result.error.message = resp['error']['message'];
            result.error.code = resp['error']['code'];
            // github.com/juju/juju/apiserver/params#ErrorInfo
            if (resp['error']['info']) {
              result.error.info = {};
              // gopkg.in/macaroon.v2-unstable#Macaroon
              result.error.info.macaroon = resp['error']['info']['macaroon'];
              result.error.info.macaroonPath = resp['error']['info']['macaroon-path'];
            }
          }
          result.result = resp['result'];
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    SetModelAgentVersion sets the model agent version.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          version: anything,
          force: bool
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error or null if the operation succeeded.
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  setModelAgentVersion(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#SetModelAgentVersion
      if (args) {
        params = {};
        // github.com/juju/version#Number
        params['version'] = args.version;
        params['force'] = args.force;
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Client',
        request: 'SetModelAgentVersion',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    SetModelConstraints sets the constraints for the model.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          application: string,
          constraints: {
            arch: string,
            container: string,
            cores: int,
            cpuPower: int,
            mem: int,
            rootDisk: int,
            tags: []string,
            instanceType: string,
            spaces: []string,
            virtType: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error or null if the operation succeeded.
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  setModelConstraints(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#SetConstraints
      if (args) {
        params = {};
        params['application'] = args.application;
        // github.com/juju/juju/constraints#Value
        if (args.constraints) {
          params['constraints'] = {};
          params['constraints']['arch'] = args.constraints.arch;
          // github.com/juju/juju/instance#ContainerType
          params['constraints']['container'] = args.constraints.container;
          params['constraints']['cores'] = args.constraints.cores;
          params['constraints']['cpu-power'] = args.constraints.cpuPower;
          params['constraints']['mem'] = args.constraints.mem;
          params['constraints']['root-disk'] = args.constraints.rootDisk;
          params['constraints']['tags'] = [];
          args.constraints.tags = args.constraints.tags || [];
          for (let i = 0; i < args.constraints.tags.length; i++) {
            params['constraints']['tags'][i] = args.constraints.tags[i];
          }
          params['constraints']['instance-type'] = args.constraints.instanceType;
          params['constraints']['spaces'] = [];
          args.constraints.spaces = args.constraints.spaces || [];
          for (let i = 0; i < args.constraints.spaces.length; i++) {
            params['constraints']['spaces'][i] = args.constraints.spaces[i];
          }
          params['constraints']['virt-type'] = args.constraints.virtType;
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Client',
        request: 'SetModelConstraints',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    SetSLALevel sets the sla level on the model.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          modelslainfo: {
            level: string,
            owner: string
          },
          creds: []int
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error or null if the operation succeeded.
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  setSLALevel(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#ModelSLA
      if (args) {
        params = {};
        // github.com/juju/juju/apiserver/params#ModelSLAInfo
        if (args.modelslainfo) {
          params['ModelSLAInfo'] = {};
          params['ModelSLAInfo']['level'] = args.modelslainfo.level;
          params['ModelSLAInfo']['owner'] = args.modelslainfo.owner;
        }
        params['creds'] = [];
        args.creds = args.creds || [];
        for (let i = 0; i < args.creds.length; i++) {
          params['creds'][i] = args.creds[i];
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Client',
        request: 'SetSLALevel',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    StatusHistory returns a slice of past statuses for several entities.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          requests: []{
            historykind: string,
            size: int,
            filter: {
              size: int,
              date: time,
              delta: int,
              exclude: []string
            },
            tag: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            history: {
              statuses: []{
                status: string,
                info: string,
                data: map[string]anything,
                since: time,
                kind: string,
                version: string,
                life: string,
                err: anything
              },
              error: {
                message: string,
                code: string,
                info: {
                  macaroon: anything,
                  macaroonPath: string
                }
              }
            },
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  statusHistory(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#StatusHistoryRequests
      if (args) {
        params = {};
        params['requests'] = [];
        args.requests = args.requests || [];
        for (let i = 0; i < args.requests.length; i++) {
          // github.com/juju/juju/apiserver/params#StatusHistoryRequest
          if (args.requests[i]) {
            params['requests'][i] = {};
            params['requests'][i]['historyKind'] = args.requests[i].historykind;
            params['requests'][i]['size'] = args.requests[i].size;
            // github.com/juju/juju/apiserver/params#StatusHistoryFilter
            if (args.requests[i].filter) {
              params['requests'][i]['filter'] = {};
              params['requests'][i]['filter']['size'] = args.requests[i].filter.size;
              // time#Time
              params['requests'][i]['filter']['date'] = args.requests[i].filter.date;
              // time#Duration
              params['requests'][i]['filter']['delta'] = args.requests[i].filter.delta;
              params['requests'][i]['filter']['exclude'] = [];
              args.requests[i].filter.exclude = args.requests[i].filter.exclude || [];
              for (let i2 = 0; i2 < args.requests[i].filter.exclude.length; i2++) {
                params['requests'][i]['filter']['exclude'][i2] = args.requests[i].filter.exclude[i2];
              }
            }
            params['requests'][i]['tag'] = args.requests[i].tag;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Client',
        request: 'StatusHistory',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#StatusHistoryResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#StatusHistoryResult
            if (resp['results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/apiserver/params#History
              if (resp['results'][i]['history']) {
                result.results[i].history = {};
                result.results[i].history.statuses = [];
                resp['results'][i]['history']['statuses'] = resp['results'][i]['history']['statuses'] || [];
                for (let i2 = 0; i2 < resp['results'][i]['history']['statuses'].length; i2++) {
                  // github.com/juju/juju/apiserver/params#DetailedStatus
                  if (resp['results'][i]['history']['statuses'][i2]) {
                    result.results[i].history.statuses[i2] = {};
                    result.results[i].history.statuses[i2].status = resp['results'][i]['history']['statuses'][i2]['status'];
                    result.results[i].history.statuses[i2].info = resp['results'][i]['history']['statuses'][i2]['info'];
                    result.results[i].history.statuses[i2].data = {};
                    resp['results'][i]['history']['statuses'][i2]['data'] = resp['results'][i]['history']['statuses'][i2]['data'] || {};
                    for (let k in resp['results'][i]['history']['statuses'][i2]['data']) {
                      result.results[i].history.statuses[i2].data[k] = resp['results'][i]['history']['statuses'][i2]['data'][k];
                    }
                    // time#Time
                    result.results[i].history.statuses[i2].since = resp['results'][i]['history']['statuses'][i2]['since'];
                    result.results[i].history.statuses[i2].kind = resp['results'][i]['history']['statuses'][i2]['kind'];
                    result.results[i].history.statuses[i2].version = resp['results'][i]['history']['statuses'][i2]['version'];
                    result.results[i].history.statuses[i2].life = resp['results'][i]['history']['statuses'][i2]['life'];
                    result.results[i].history.statuses[i2].err = resp['results'][i]['history']['statuses'][i2]['err'];
                  }
                }
                // github.com/juju/juju/apiserver/params#Error
                if (resp['results'][i]['history']['error']) {
                  result.results[i].history.error = {};
                  result.results[i].history.error.message = resp['results'][i]['history']['error']['message'];
                  result.results[i].history.error.code = resp['results'][i]['history']['error']['code'];
                  // github.com/juju/juju/apiserver/params#ErrorInfo
                  if (resp['results'][i]['history']['error']['info']) {
                    result.results[i].history.error.info = {};
                    // gopkg.in/macaroon.v2-unstable#Macaroon
                    result.results[i].history.error.info.macaroon = resp['results'][i]['history']['error']['info']['macaroon'];
                    result.results[i].history.error.info.macaroonPath = resp['results'][i]['history']['error']['info']['macaroon-path'];
                  }
                }
              }
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    WatchAll initiates a watcher for entities in the connected model.

    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          watcherId: string
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  watchAll(callback) {
    return new Promise((resolve, reject) => {
      const params = {};
      // Prepare the request to the Juju API.
      const req = {
        type: 'Client',
        request: 'WatchAll',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#AllWatcherId
        if (resp) {
          result = {};
          result.watcherId = resp['watcher-id'];
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }
}


const wrappers = require('../wrappers.js');
if (wrappers.wrapClient) {
  // Decorate the facade class in order to improve user experience.
  ClientV2 = wrappers.wrapClient(ClientV2);
}

module.exports = ClientV2;