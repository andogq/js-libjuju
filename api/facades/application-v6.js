/**
  Juju Application version 6.
  This API facade is available on model connections.

  NOTE: this file has been generated by the generate command in js-libjuju
  on Tue 2018/11/27 16:23:13 UTC. Do not manually edit this file.
*/

'use strict';

const {autoBind, createAsyncHandler} = require('../transform.js');

/**
  APIv6 provides the Application API facade for version 6.
*/
class ApplicationV6 {

  constructor(transport, info) {
    this._transport = transport;
    this._info = info;
    this.version = 6;

    // Automatically bind all methods to instances.
    autoBind(this);
  }

  /**
    AddRelation adds a relation between the specified endpoints and returns the
    relation info.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          endpoints: []string,
          viaCidrs: []string
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          endpoints: map[string]{
            name: string,
            role: string,
            interface: string,
            optional: bool,
            limit: int,
            scope: string
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  addRelation(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#AddRelation
      if (args) {
        params = {};
        params['endpoints'] = [];
        args.endpoints = args.endpoints || [];
        for (let i = 0; i < args.endpoints.length; i++) {
          params['endpoints'][i] = args.endpoints[i];
        }
        params['via-cidrs'] = [];
        args.viaCidrs = args.viaCidrs || [];
        for (let i = 0; i < args.viaCidrs.length; i++) {
          params['via-cidrs'][i] = args.viaCidrs[i];
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Application',
        request: 'AddRelation',
        version: 6,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#AddRelationResults
        if (resp) {
          result = {};
          result.endpoints = {};
          resp['endpoints'] = resp['endpoints'] || {};
          for (let k in resp['endpoints']) {
            // github.com/juju/juju/apiserver/params#CharmRelation
            if (resp['endpoints'][k]) {
              result.endpoints[k] = {};
              result.endpoints[k].name = resp['endpoints'][k]['name'];
              result.endpoints[k].role = resp['endpoints'][k]['role'];
              result.endpoints[k].interface = resp['endpoints'][k]['interface'];
              result.endpoints[k].optional = resp['endpoints'][k]['optional'];
              result.endpoints[k].limit = resp['endpoints'][k]['limit'];
              result.endpoints[k].scope = resp['endpoints'][k]['scope'];
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    AddUnits adds a given number of units to an application.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          application: string,
          numUnits: int,
          placement: []{
            scope: string,
            directive: string
          },
          policy: string,
          attachStorage: []string
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          units: []string
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  addUnits(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#AddApplicationUnits
      if (args) {
        params = {};
        params['application'] = args.application;
        params['num-units'] = args.numUnits;
        params['placement'] = [];
        args.placement = args.placement || [];
        for (let i = 0; i < args.placement.length; i++) {
          // github.com/juju/juju/instance#Placement
          if (args.placement[i]) {
            params['placement'][i] = {};
            params['placement'][i]['scope'] = args.placement[i].scope;
            params['placement'][i]['directive'] = args.placement[i].directive;
          }
        }
        params['policy'] = args.policy;
        params['attach-storage'] = [];
        args.attachStorage = args.attachStorage || [];
        for (let i = 0; i < args.attachStorage.length; i++) {
          params['attach-storage'][i] = args.attachStorage[i];
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Application',
        request: 'AddUnits',
        version: 6,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#AddApplicationUnitsResults
        if (resp) {
          result = {};
          result.units = [];
          resp['units'] = resp['units'] || [];
          for (let i = 0; i < resp['units'].length; i++) {
            result.units[i] = resp['units'][i];
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    CharmConfig is a shim to GetConfig on APIv5. It returns just the charm
    config.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          entities: []{
            tag: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            config: map[string]anything,
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  charmConfig(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#Entities
      if (args) {
        params = {};
        params['entities'] = [];
        args.entities = args.entities || [];
        for (let i = 0; i < args.entities.length; i++) {
          // github.com/juju/juju/apiserver/params#Entity
          if (args.entities[i]) {
            params['entities'][i] = {};
            params['entities'][i]['tag'] = args.entities[i].tag;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Application',
        request: 'CharmConfig',
        version: 6,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ApplicationGetConfigResults
        if (resp) {
          result = {};
          result.results = [];
          resp['Results'] = resp['Results'] || [];
          for (let i = 0; i < resp['Results'].length; i++) {
            // github.com/juju/juju/apiserver/params#ConfigResult
            if (resp['Results'][i]) {
              result.results[i] = {};
              result.results[i].config = {};
              resp['Results'][i]['config'] = resp['Results'][i]['config'] || {};
              for (let k in resp['Results'][i]['config']) {
                result.results[i].config[k] = resp['Results'][i]['config'][k];
              }
              // github.com/juju/juju/apiserver/params#Error
              if (resp['Results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['Results'][i]['error']['message'];
                result.results[i].error.code = resp['Results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['Results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['Results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['Results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    CharmRelations implements the server side of Application.CharmRelations.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          application: string
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          charmRelations: []string
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  charmRelations(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#ApplicationCharmRelations
      if (args) {
        params = {};
        params['application'] = args.application;
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Application',
        request: 'CharmRelations',
        version: 6,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ApplicationCharmRelationsResults
        if (resp) {
          result = {};
          result.charmRelations = [];
          resp['charm-relations'] = resp['charm-relations'] || [];
          for (let i = 0; i < resp['charm-relations'].length; i++) {
            result.charmRelations[i] = resp['charm-relations'][i];
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    Consume adds remote applications to the model without creating any
    relations.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          args: []{
            applicationofferdetails: {
              sourceModelTag: string,
              offerUuid: string,
              offerUrl: string,
              offerName: string,
              applicationDescription: string,
              endpoints: []{
                name: string,
                role: string,
                interface: string,
                limit: int
              },
              spaces: []{
                cloudType: string,
                name: string,
                providerId: string,
                providerAttributes: map[string]anything,
                subnets: []{
                  cidr: string,
                  providerId: string,
                  providerNetworkId: string,
                  providerSpaceId: string,
                  vlanTag: int,
                  life: string,
                  spaceTag: string,
                  zones: []string,
                  status: string
                }
              },
              bindings: map[string]string,
              users: []{
                user: string,
                displayName: string,
                access: string
              }
            },
            macaroon: anything,
            externalController: {
              controllerTag: string,
              controllerAlias: string,
              addrs: []string,
              caCert: string
            },
            applicationAlias: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  consume(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#ConsumeApplicationArgs
      if (args) {
        params = {};
        params['args'] = [];
        args.args = args.args || [];
        for (let i = 0; i < args.args.length; i++) {
          // github.com/juju/juju/apiserver/params#ConsumeApplicationArg
          if (args.args[i]) {
            params['args'][i] = {};
            // github.com/juju/juju/apiserver/params#ApplicationOfferDetails
            if (args.args[i].applicationofferdetails) {
              params['args'][i]['ApplicationOfferDetails'] = {};
              params['args'][i]['ApplicationOfferDetails']['source-model-tag'] = args.args[i].applicationofferdetails.sourceModelTag;
              params['args'][i]['ApplicationOfferDetails']['offer-uuid'] = args.args[i].applicationofferdetails.offerUuid;
              params['args'][i]['ApplicationOfferDetails']['offer-url'] = args.args[i].applicationofferdetails.offerUrl;
              params['args'][i]['ApplicationOfferDetails']['offer-name'] = args.args[i].applicationofferdetails.offerName;
              params['args'][i]['ApplicationOfferDetails']['application-description'] = args.args[i].applicationofferdetails.applicationDescription;
              params['args'][i]['ApplicationOfferDetails']['endpoints'] = [];
              args.args[i].applicationofferdetails.endpoints = args.args[i].applicationofferdetails.endpoints || [];
              for (let i2 = 0; i2 < args.args[i].applicationofferdetails.endpoints.length; i2++) {
                // github.com/juju/juju/apiserver/params#RemoteEndpoint
                if (args.args[i].applicationofferdetails.endpoints[i2]) {
                  params['args'][i]['ApplicationOfferDetails']['endpoints'][i2] = {};
                  params['args'][i]['ApplicationOfferDetails']['endpoints'][i2]['name'] = args.args[i].applicationofferdetails.endpoints[i2].name;
                  // gopkg.in/juju/charm.v6#RelationRole
                  params['args'][i]['ApplicationOfferDetails']['endpoints'][i2]['role'] = args.args[i].applicationofferdetails.endpoints[i2].role;
                  params['args'][i]['ApplicationOfferDetails']['endpoints'][i2]['interface'] = args.args[i].applicationofferdetails.endpoints[i2].interface;
                  params['args'][i]['ApplicationOfferDetails']['endpoints'][i2]['limit'] = args.args[i].applicationofferdetails.endpoints[i2].limit;
                }
              }
              params['args'][i]['ApplicationOfferDetails']['spaces'] = [];
              args.args[i].applicationofferdetails.spaces = args.args[i].applicationofferdetails.spaces || [];
              for (let i2 = 0; i2 < args.args[i].applicationofferdetails.spaces.length; i2++) {
                // github.com/juju/juju/apiserver/params#RemoteSpace
                if (args.args[i].applicationofferdetails.spaces[i2]) {
                  params['args'][i]['ApplicationOfferDetails']['spaces'][i2] = {};
                  params['args'][i]['ApplicationOfferDetails']['spaces'][i2]['cloud-type'] = args.args[i].applicationofferdetails.spaces[i2].cloudType;
                  params['args'][i]['ApplicationOfferDetails']['spaces'][i2]['name'] = args.args[i].applicationofferdetails.spaces[i2].name;
                  params['args'][i]['ApplicationOfferDetails']['spaces'][i2]['provider-id'] = args.args[i].applicationofferdetails.spaces[i2].providerId;
                  params['args'][i]['ApplicationOfferDetails']['spaces'][i2]['provider-attributes'] = {};
                  args.args[i].applicationofferdetails.spaces[i2].providerAttributes = args.args[i].applicationofferdetails.spaces[i2].providerAttributes || {};
                  for (let k in args.args[i].applicationofferdetails.spaces[i2].providerAttributes) {
                    params['args'][i]['ApplicationOfferDetails']['spaces'][i2]['provider-attributes'][k] = args.args[i].applicationofferdetails.spaces[i2].providerAttributes[k];
                  }
                  params['args'][i]['ApplicationOfferDetails']['spaces'][i2]['subnets'] = [];
                  args.args[i].applicationofferdetails.spaces[i2].subnets = args.args[i].applicationofferdetails.spaces[i2].subnets || [];
                  for (let i3 = 0; i3 < args.args[i].applicationofferdetails.spaces[i2].subnets.length; i3++) {
                    // github.com/juju/juju/apiserver/params#Subnet
                    if (args.args[i].applicationofferdetails.spaces[i2].subnets[i3]) {
                      params['args'][i]['ApplicationOfferDetails']['spaces'][i2]['subnets'][i3] = {};
                      params['args'][i]['ApplicationOfferDetails']['spaces'][i2]['subnets'][i3]['cidr'] = args.args[i].applicationofferdetails.spaces[i2].subnets[i3].cidr;
                      params['args'][i]['ApplicationOfferDetails']['spaces'][i2]['subnets'][i3]['provider-id'] = args.args[i].applicationofferdetails.spaces[i2].subnets[i3].providerId;
                      params['args'][i]['ApplicationOfferDetails']['spaces'][i2]['subnets'][i3]['provider-network-id'] = args.args[i].applicationofferdetails.spaces[i2].subnets[i3].providerNetworkId;
                      params['args'][i]['ApplicationOfferDetails']['spaces'][i2]['subnets'][i3]['provider-space-id'] = args.args[i].applicationofferdetails.spaces[i2].subnets[i3].providerSpaceId;
                      params['args'][i]['ApplicationOfferDetails']['spaces'][i2]['subnets'][i3]['vlan-tag'] = args.args[i].applicationofferdetails.spaces[i2].subnets[i3].vlanTag;
                      // github.com/juju/juju/apiserver/params#Life
                      params['args'][i]['ApplicationOfferDetails']['spaces'][i2]['subnets'][i3]['life'] = args.args[i].applicationofferdetails.spaces[i2].subnets[i3].life;
                      params['args'][i]['ApplicationOfferDetails']['spaces'][i2]['subnets'][i3]['space-tag'] = args.args[i].applicationofferdetails.spaces[i2].subnets[i3].spaceTag;
                      params['args'][i]['ApplicationOfferDetails']['spaces'][i2]['subnets'][i3]['zones'] = [];
                      args.args[i].applicationofferdetails.spaces[i2].subnets[i3].zones = args.args[i].applicationofferdetails.spaces[i2].subnets[i3].zones || [];
                      for (let i4 = 0; i4 < args.args[i].applicationofferdetails.spaces[i2].subnets[i3].zones.length; i4++) {
                        params['args'][i]['ApplicationOfferDetails']['spaces'][i2]['subnets'][i3]['zones'][i4] = args.args[i].applicationofferdetails.spaces[i2].subnets[i3].zones[i4];
                      }
                      params['args'][i]['ApplicationOfferDetails']['spaces'][i2]['subnets'][i3]['status'] = args.args[i].applicationofferdetails.spaces[i2].subnets[i3].status;
                    }
                  }
                }
              }
              params['args'][i]['ApplicationOfferDetails']['bindings'] = {};
              args.args[i].applicationofferdetails.bindings = args.args[i].applicationofferdetails.bindings || {};
              for (let k in args.args[i].applicationofferdetails.bindings) {
                params['args'][i]['ApplicationOfferDetails']['bindings'][k] = args.args[i].applicationofferdetails.bindings[k];
              }
              params['args'][i]['ApplicationOfferDetails']['users'] = [];
              args.args[i].applicationofferdetails.users = args.args[i].applicationofferdetails.users || [];
              for (let i2 = 0; i2 < args.args[i].applicationofferdetails.users.length; i2++) {
                // github.com/juju/juju/apiserver/params#OfferUserDetails
                if (args.args[i].applicationofferdetails.users[i2]) {
                  params['args'][i]['ApplicationOfferDetails']['users'][i2] = {};
                  params['args'][i]['ApplicationOfferDetails']['users'][i2]['user'] = args.args[i].applicationofferdetails.users[i2].user;
                  params['args'][i]['ApplicationOfferDetails']['users'][i2]['display-name'] = args.args[i].applicationofferdetails.users[i2].displayName;
                  params['args'][i]['ApplicationOfferDetails']['users'][i2]['access'] = args.args[i].applicationofferdetails.users[i2].access;
                }
              }
            }
            // gopkg.in/macaroon.v2-unstable#Macaroon
            params['args'][i]['macaroon'] = args.args[i].macaroon;
            // github.com/juju/juju/apiserver/params#ExternalControllerInfo
            if (args.args[i].externalController) {
              params['args'][i]['external-controller'] = {};
              params['args'][i]['external-controller']['controller-tag'] = args.args[i].externalController.controllerTag;
              params['args'][i]['external-controller']['controller-alias'] = args.args[i].externalController.controllerAlias;
              params['args'][i]['external-controller']['addrs'] = [];
              args.args[i].externalController.addrs = args.args[i].externalController.addrs || [];
              for (let i2 = 0; i2 < args.args[i].externalController.addrs.length; i2++) {
                params['args'][i]['external-controller']['addrs'][i2] = args.args[i].externalController.addrs[i2];
              }
              params['args'][i]['external-controller']['ca-cert'] = args.args[i].externalController.caCert;
            }
            params['args'][i]['application-alias'] = args.args[i].applicationAlias;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Application',
        request: 'Consume',
        version: 6,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ErrorResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#ErrorResult
            if (resp['results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    Deploy fetches the charms from the charm store and deploys them using the
    specified placement directives. V6 deploy did not support devices, so
    pass through an empty map.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          applications: []{
            application: string,
            series: string,
            charmUrl: string,
            channel: string,
            numUnits: int,
            config: map[string]string,
            configYaml: string,
            constraints: {
              arch: string,
              container: string,
              cores: int,
              cpuPower: int,
              mem: int,
              rootDisk: int,
              tags: []string,
              instanceType: string,
              spaces: []string,
              virtType: string
            },
            placement: []{
              scope: string,
              directive: string
            },
            policy: string,
            storage: map[string]{
              pool: string,
              size: int,
              count: int
            },
            attachStorage: []string,
            endpointBindings: map[string]string,
            resources: map[string]string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  deploy(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#ApplicationsDeployV6
      if (args) {
        params = {};
        params['applications'] = [];
        args.applications = args.applications || [];
        for (let i = 0; i < args.applications.length; i++) {
          // github.com/juju/juju/apiserver/params#ApplicationDeployV6
          if (args.applications[i]) {
            params['applications'][i] = {};
            params['applications'][i]['application'] = args.applications[i].application;
            params['applications'][i]['series'] = args.applications[i].series;
            params['applications'][i]['charm-url'] = args.applications[i].charmUrl;
            params['applications'][i]['channel'] = args.applications[i].channel;
            params['applications'][i]['num-units'] = args.applications[i].numUnits;
            params['applications'][i]['config'] = {};
            args.applications[i].config = args.applications[i].config || {};
            for (let k in args.applications[i].config) {
              params['applications'][i]['config'][k] = args.applications[i].config[k];
            }
            params['applications'][i]['config-yaml'] = args.applications[i].configYaml;
            // github.com/juju/juju/constraints#Value
            if (args.applications[i].constraints) {
              params['applications'][i]['constraints'] = {};
              params['applications'][i]['constraints']['arch'] = args.applications[i].constraints.arch;
              // github.com/juju/juju/instance#ContainerType
              params['applications'][i]['constraints']['container'] = args.applications[i].constraints.container;
              params['applications'][i]['constraints']['cores'] = args.applications[i].constraints.cores;
              params['applications'][i]['constraints']['cpu-power'] = args.applications[i].constraints.cpuPower;
              params['applications'][i]['constraints']['mem'] = args.applications[i].constraints.mem;
              params['applications'][i]['constraints']['root-disk'] = args.applications[i].constraints.rootDisk;
              params['applications'][i]['constraints']['tags'] = [];
              args.applications[i].constraints.tags = args.applications[i].constraints.tags || [];
              for (let i2 = 0; i2 < args.applications[i].constraints.tags.length; i2++) {
                params['applications'][i]['constraints']['tags'][i2] = args.applications[i].constraints.tags[i2];
              }
              params['applications'][i]['constraints']['instance-type'] = args.applications[i].constraints.instanceType;
              params['applications'][i]['constraints']['spaces'] = [];
              args.applications[i].constraints.spaces = args.applications[i].constraints.spaces || [];
              for (let i2 = 0; i2 < args.applications[i].constraints.spaces.length; i2++) {
                params['applications'][i]['constraints']['spaces'][i2] = args.applications[i].constraints.spaces[i2];
              }
              params['applications'][i]['constraints']['virt-type'] = args.applications[i].constraints.virtType;
            }
            params['applications'][i]['placement'] = [];
            args.applications[i].placement = args.applications[i].placement || [];
            for (let i2 = 0; i2 < args.applications[i].placement.length; i2++) {
              // github.com/juju/juju/instance#Placement
              if (args.applications[i].placement[i2]) {
                params['applications'][i]['placement'][i2] = {};
                params['applications'][i]['placement'][i2]['scope'] = args.applications[i].placement[i2].scope;
                params['applications'][i]['placement'][i2]['directive'] = args.applications[i].placement[i2].directive;
              }
            }
            params['applications'][i]['policy'] = args.applications[i].policy;
            params['applications'][i]['storage'] = {};
            args.applications[i].storage = args.applications[i].storage || {};
            for (let k in args.applications[i].storage) {
              // github.com/juju/juju/storage#Constraints
              if (args.applications[i].storage[k]) {
                params['applications'][i]['storage'][k] = {};
                params['applications'][i]['storage'][k]['Pool'] = args.applications[i].storage[k].pool;
                params['applications'][i]['storage'][k]['Size'] = args.applications[i].storage[k].size;
                params['applications'][i]['storage'][k]['Count'] = args.applications[i].storage[k].count;
              }
            }
            params['applications'][i]['attach-storage'] = [];
            args.applications[i].attachStorage = args.applications[i].attachStorage || [];
            for (let i2 = 0; i2 < args.applications[i].attachStorage.length; i2++) {
              params['applications'][i]['attach-storage'][i2] = args.applications[i].attachStorage[i2];
            }
            params['applications'][i]['endpoint-bindings'] = {};
            args.applications[i].endpointBindings = args.applications[i].endpointBindings || {};
            for (let k in args.applications[i].endpointBindings) {
              params['applications'][i]['endpoint-bindings'][k] = args.applications[i].endpointBindings[k];
            }
            params['applications'][i]['resources'] = {};
            args.applications[i].resources = args.applications[i].resources || {};
            for (let k in args.applications[i].resources) {
              params['applications'][i]['resources'][k] = args.applications[i].resources[k];
            }
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Application',
        request: 'Deploy',
        version: 6,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ErrorResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#ErrorResult
            if (resp['results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    Destroy destroys a given application, local or remote.  NOTE(axw) this
    exists only for backwards compatibility, for API facade versions 1-3;
    clients should prefer its successor, DestroyApplication, below. Until
    all consumers have been updated, or we bump a major version, we can't
    drop this.  TODO(axw) 2017-03-16 #1673323 Drop this in Juju 3.0.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          application: string
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error or null if the operation succeeded.
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  destroy(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#ApplicationDestroy
      if (args) {
        params = {};
        params['application'] = args.application;
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Application',
        request: 'Destroy',
        version: 6,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    DestroyApplication removes a given set of applications.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          applications: []{
            applicationTag: string,
            destroyStorage: bool
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            },
            info: {
              detachedStorage: []{
                tag: string
              },
              destroyedStorage: []{
                tag: string
              },
              destroyedUnits: []{
                tag: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  destroyApplication(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#DestroyApplicationsParams
      if (args) {
        params = {};
        params['applications'] = [];
        args.applications = args.applications || [];
        for (let i = 0; i < args.applications.length; i++) {
          // github.com/juju/juju/apiserver/params#DestroyApplicationParams
          if (args.applications[i]) {
            params['applications'][i] = {};
            params['applications'][i]['application-tag'] = args.applications[i].applicationTag;
            params['applications'][i]['destroy-storage'] = args.applications[i].destroyStorage;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Application',
        request: 'DestroyApplication',
        version: 6,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#DestroyApplicationResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#DestroyApplicationResult
            if (resp['results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
              // github.com/juju/juju/apiserver/params#DestroyApplicationInfo
              if (resp['results'][i]['info']) {
                result.results[i].info = {};
                result.results[i].info.detachedStorage = [];
                resp['results'][i]['info']['detached-storage'] = resp['results'][i]['info']['detached-storage'] || [];
                for (let i2 = 0; i2 < resp['results'][i]['info']['detached-storage'].length; i2++) {
                  // github.com/juju/juju/apiserver/params#Entity
                  if (resp['results'][i]['info']['detached-storage'][i2]) {
                    result.results[i].info.detachedStorage[i2] = {};
                    result.results[i].info.detachedStorage[i2].tag = resp['results'][i]['info']['detached-storage'][i2]['tag'];
                  }
                }
                result.results[i].info.destroyedStorage = [];
                resp['results'][i]['info']['destroyed-storage'] = resp['results'][i]['info']['destroyed-storage'] || [];
                for (let i2 = 0; i2 < resp['results'][i]['info']['destroyed-storage'].length; i2++) {
                  // github.com/juju/juju/apiserver/params#Entity
                  if (resp['results'][i]['info']['destroyed-storage'][i2]) {
                    result.results[i].info.destroyedStorage[i2] = {};
                    result.results[i].info.destroyedStorage[i2].tag = resp['results'][i]['info']['destroyed-storage'][i2]['tag'];
                  }
                }
                result.results[i].info.destroyedUnits = [];
                resp['results'][i]['info']['destroyed-units'] = resp['results'][i]['info']['destroyed-units'] || [];
                for (let i2 = 0; i2 < resp['results'][i]['info']['destroyed-units'].length; i2++) {
                  // github.com/juju/juju/apiserver/params#Entity
                  if (resp['results'][i]['info']['destroyed-units'][i2]) {
                    result.results[i].info.destroyedUnits[i2] = {};
                    result.results[i].info.destroyedUnits[i2].tag = resp['results'][i]['info']['destroyed-units'][i2]['tag'];
                  }
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    DestroyConsumedApplications removes a given set of consumed (remote)
    applications.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          applications: []{
            applicationTag: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  destroyConsumedApplications(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#DestroyConsumedApplicationsParams
      if (args) {
        params = {};
        params['applications'] = [];
        args.applications = args.applications || [];
        for (let i = 0; i < args.applications.length; i++) {
          // github.com/juju/juju/apiserver/params#DestroyConsumedApplicationParams
          if (args.applications[i]) {
            params['applications'][i] = {};
            params['applications'][i]['application-tag'] = args.applications[i].applicationTag;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Application',
        request: 'DestroyConsumedApplications',
        version: 6,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ErrorResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#ErrorResult
            if (resp['results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    DestroyRelation removes the relation between the specified endpoints or an
    id.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          endpoints: []string,
          relationId: int
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error or null if the operation succeeded.
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  destroyRelation(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#DestroyRelation
      if (args) {
        params = {};
        params['endpoints'] = [];
        args.endpoints = args.endpoints || [];
        for (let i = 0; i < args.endpoints.length; i++) {
          params['endpoints'][i] = args.endpoints[i];
        }
        params['relation-id'] = args.relationId;
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Application',
        request: 'DestroyRelation',
        version: 6,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    DestroyUnit removes a given set of application units.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          units: []{
            unitTag: string,
            destroyStorage: bool
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            },
            info: {
              detachedStorage: []{
                tag: string
              },
              destroyedStorage: []{
                tag: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  destroyUnit(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#DestroyUnitsParams
      if (args) {
        params = {};
        params['units'] = [];
        args.units = args.units || [];
        for (let i = 0; i < args.units.length; i++) {
          // github.com/juju/juju/apiserver/params#DestroyUnitParams
          if (args.units[i]) {
            params['units'][i] = {};
            params['units'][i]['unit-tag'] = args.units[i].unitTag;
            params['units'][i]['destroy-storage'] = args.units[i].destroyStorage;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Application',
        request: 'DestroyUnit',
        version: 6,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#DestroyUnitResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#DestroyUnitResult
            if (resp['results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
              // github.com/juju/juju/apiserver/params#DestroyUnitInfo
              if (resp['results'][i]['info']) {
                result.results[i].info = {};
                result.results[i].info.detachedStorage = [];
                resp['results'][i]['info']['detached-storage'] = resp['results'][i]['info']['detached-storage'] || [];
                for (let i2 = 0; i2 < resp['results'][i]['info']['detached-storage'].length; i2++) {
                  // github.com/juju/juju/apiserver/params#Entity
                  if (resp['results'][i]['info']['detached-storage'][i2]) {
                    result.results[i].info.detachedStorage[i2] = {};
                    result.results[i].info.detachedStorage[i2].tag = resp['results'][i]['info']['detached-storage'][i2]['tag'];
                  }
                }
                result.results[i].info.destroyedStorage = [];
                resp['results'][i]['info']['destroyed-storage'] = resp['results'][i]['info']['destroyed-storage'] || [];
                for (let i2 = 0; i2 < resp['results'][i]['info']['destroyed-storage'].length; i2++) {
                  // github.com/juju/juju/apiserver/params#Entity
                  if (resp['results'][i]['info']['destroyed-storage'][i2]) {
                    result.results[i].info.destroyedStorage[i2] = {};
                    result.results[i].info.destroyedStorage[i2].tag = resp['results'][i]['info']['destroyed-storage'][i2]['tag'];
                  }
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    DestroyUnits removes a given set of application units.  NOTE(axw) this
    exists only for backwards compatibility, for API facade versions 1-3;
    clients should prefer its successor, DestroyUnit, below. Until all
    consumers have been updated, or we bump a major version, we can't drop
    this.  TODO(axw) 2017-03-16 #1673323 Drop this in Juju 3.0.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          unitNames: []string
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error or null if the operation succeeded.
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  destroyUnits(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#DestroyApplicationUnits
      if (args) {
        params = {};
        params['unit-names'] = [];
        args.unitNames = args.unitNames || [];
        for (let i = 0; i < args.unitNames.length; i++) {
          params['unit-names'][i] = args.unitNames[i];
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Application',
        request: 'DestroyUnits',
        version: 6,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    Expose changes the juju-managed firewall to expose any ports that were also
    explicitly marked by units as open.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          application: string
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error or null if the operation succeeded.
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  expose(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#ApplicationExpose
      if (args) {
        params = {};
        params['application'] = args.application;
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Application',
        request: 'Expose',
        version: 6,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    Get returns the charm configuration for an application.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          application: string
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          application: string,
          charm: string,
          config: map[string]anything,
          applicationConfig: map[string]anything,
          constraints: {
            arch: string,
            container: string,
            cores: int,
            cpuPower: int,
            mem: int,
            rootDisk: int,
            tags: []string,
            instanceType: string,
            spaces: []string,
            virtType: string
          },
          series: string
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  get(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#ApplicationGet
      if (args) {
        params = {};
        params['application'] = args.application;
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Application',
        request: 'Get',
        version: 6,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ApplicationGetResults
        if (resp) {
          result = {};
          result.application = resp['application'];
          result.charm = resp['charm'];
          result.config = {};
          resp['config'] = resp['config'] || {};
          for (let k in resp['config']) {
            result.config[k] = resp['config'][k];
          }
          result.applicationConfig = {};
          resp['application-config'] = resp['application-config'] || {};
          for (let k in resp['application-config']) {
            result.applicationConfig[k] = resp['application-config'][k];
          }
          // github.com/juju/juju/constraints#Value
          if (resp['constraints']) {
            result.constraints = {};
            result.constraints.arch = resp['constraints']['arch'];
            // github.com/juju/juju/instance#ContainerType
            result.constraints.container = resp['constraints']['container'];
            result.constraints.cores = resp['constraints']['cores'];
            result.constraints.cpuPower = resp['constraints']['cpu-power'];
            result.constraints.mem = resp['constraints']['mem'];
            result.constraints.rootDisk = resp['constraints']['root-disk'];
            result.constraints.tags = [];
            resp['constraints']['tags'] = resp['constraints']['tags'] || [];
            for (let i = 0; i < resp['constraints']['tags'].length; i++) {
              result.constraints.tags[i] = resp['constraints']['tags'][i];
            }
            result.constraints.instanceType = resp['constraints']['instance-type'];
            result.constraints.spaces = [];
            resp['constraints']['spaces'] = resp['constraints']['spaces'] || [];
            for (let i = 0; i < resp['constraints']['spaces'].length; i++) {
              result.constraints.spaces[i] = resp['constraints']['spaces'][i];
            }
            result.constraints.virtType = resp['constraints']['virt-type'];
          }
          result.series = resp['series'];
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    GetCharmURL returns the charm URL the given application is running at
    present.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          application: string
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          error: {
            message: string,
            code: string,
            info: {
              macaroon: anything,
              macaroonPath: string
            }
          },
          result: string
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  getCharmURL(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#ApplicationGet
      if (args) {
        params = {};
        params['application'] = args.application;
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Application',
        request: 'GetCharmURL',
        version: 6,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#StringResult
        if (resp) {
          result = {};
          // github.com/juju/juju/apiserver/params#Error
          if (resp['error']) {
            result.error = {};
            result.error.message = resp['error']['message'];
            result.error.code = resp['error']['code'];
            // github.com/juju/juju/apiserver/params#ErrorInfo
            if (resp['error']['info']) {
              result.error.info = {};
              // gopkg.in/macaroon.v2-unstable#Macaroon
              result.error.info.macaroon = resp['error']['info']['macaroon'];
              result.error.info.macaroonPath = resp['error']['info']['macaroon-path'];
            }
          }
          result.result = resp['result'];
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    GetConfig returns the charm config for each of the applications asked for.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          entities: []{
            tag: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            config: map[string]anything,
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  getConfig(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#Entities
      if (args) {
        params = {};
        params['entities'] = [];
        args.entities = args.entities || [];
        for (let i = 0; i < args.entities.length; i++) {
          // github.com/juju/juju/apiserver/params#Entity
          if (args.entities[i]) {
            params['entities'][i] = {};
            params['entities'][i]['tag'] = args.entities[i].tag;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Application',
        request: 'GetConfig',
        version: 6,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ApplicationGetConfigResults
        if (resp) {
          result = {};
          result.results = [];
          resp['Results'] = resp['Results'] || [];
          for (let i = 0; i < resp['Results'].length; i++) {
            // github.com/juju/juju/apiserver/params#ConfigResult
            if (resp['Results'][i]) {
              result.results[i] = {};
              result.results[i].config = {};
              resp['Results'][i]['config'] = resp['Results'][i]['config'] || {};
              for (let k in resp['Results'][i]['config']) {
                result.results[i].config[k] = resp['Results'][i]['config'][k];
              }
              // github.com/juju/juju/apiserver/params#Error
              if (resp['Results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['Results'][i]['error']['message'];
                result.results[i].error.code = resp['Results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['Results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['Results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['Results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    GetConstraints returns the constraints for a given application.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          entities: []{
            tag: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            constraints: {
              arch: string,
              container: string,
              cores: int,
              cpuPower: int,
              mem: int,
              rootDisk: int,
              tags: []string,
              instanceType: string,
              spaces: []string,
              virtType: string
            },
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  getConstraints(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#Entities
      if (args) {
        params = {};
        params['entities'] = [];
        args.entities = args.entities || [];
        for (let i = 0; i < args.entities.length; i++) {
          // github.com/juju/juju/apiserver/params#Entity
          if (args.entities[i]) {
            params['entities'][i] = {};
            params['entities'][i]['tag'] = args.entities[i].tag;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Application',
        request: 'GetConstraints',
        version: 6,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ApplicationGetConstraintsResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#ApplicationConstraint
            if (resp['results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/constraints#Value
              if (resp['results'][i]['constraints']) {
                result.results[i].constraints = {};
                result.results[i].constraints.arch = resp['results'][i]['constraints']['arch'];
                // github.com/juju/juju/instance#ContainerType
                result.results[i].constraints.container = resp['results'][i]['constraints']['container'];
                result.results[i].constraints.cores = resp['results'][i]['constraints']['cores'];
                result.results[i].constraints.cpuPower = resp['results'][i]['constraints']['cpu-power'];
                result.results[i].constraints.mem = resp['results'][i]['constraints']['mem'];
                result.results[i].constraints.rootDisk = resp['results'][i]['constraints']['root-disk'];
                result.results[i].constraints.tags = [];
                resp['results'][i]['constraints']['tags'] = resp['results'][i]['constraints']['tags'] || [];
                for (let i2 = 0; i2 < resp['results'][i]['constraints']['tags'].length; i2++) {
                  result.results[i].constraints.tags[i2] = resp['results'][i]['constraints']['tags'][i2];
                }
                result.results[i].constraints.instanceType = resp['results'][i]['constraints']['instance-type'];
                result.results[i].constraints.spaces = [];
                resp['results'][i]['constraints']['spaces'] = resp['results'][i]['constraints']['spaces'] || [];
                for (let i2 = 0; i2 < resp['results'][i]['constraints']['spaces'].length; i2++) {
                  result.results[i].constraints.spaces[i2] = resp['results'][i]['constraints']['spaces'][i2];
                }
                result.results[i].constraints.virtType = resp['results'][i]['constraints']['virt-type'];
              }
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    GetLXDProfileUpgradeMessages returns the lxd profile messages associated
    with a application and set of machines

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          application: {
            tag: string
          },
          watcherId: string
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          args: []{
            unitName: string,
            message: string,
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  getLXDProfileUpgradeMessages(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#LXDProfileUpgradeMessages
      if (args) {
        params = {};
        // github.com/juju/juju/apiserver/params#Entity
        if (args.application) {
          params['application'] = {};
          params['application']['tag'] = args.application.tag;
        }
        params['watcher-id'] = args.watcherId;
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Application',
        request: 'GetLXDProfileUpgradeMessages',
        version: 6,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#LXDProfileUpgradeMessagesResults
        if (resp) {
          result = {};
          result.args = [];
          resp['args'] = resp['args'] || [];
          for (let i = 0; i < resp['args'].length; i++) {
            // github.com/juju/juju/apiserver/params#LXDProfileUpgradeMessagesResult
            if (resp['args'][i]) {
              result.args[i] = {};
              result.args[i].unitName = resp['args'][i]['unit-name'];
              result.args[i].message = resp['args'][i]['message'];
              // github.com/juju/juju/apiserver/params#Error
              if (resp['args'][i]['error']) {
                result.args[i].error = {};
                result.args[i].error.message = resp['args'][i]['error']['message'];
                result.args[i].error.code = resp['args'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['args'][i]['error']['info']) {
                  result.args[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.args[i].error.info.macaroon = resp['args'][i]['error']['info']['macaroon'];
                  result.args[i].error.info.macaroonPath = resp['args'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    ResolveUnitErrors marks errors on the specified units as resolved.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          tags: {
            entities: []{
              tag: string
            }
          },
          retry: bool,
          all: bool
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  resolveUnitErrors(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#UnitsResolved
      if (args) {
        params = {};
        // github.com/juju/juju/apiserver/params#Entities
        if (args.tags) {
          params['tags'] = {};
          params['tags']['entities'] = [];
          args.tags.entities = args.tags.entities || [];
          for (let i = 0; i < args.tags.entities.length; i++) {
            // github.com/juju/juju/apiserver/params#Entity
            if (args.tags.entities[i]) {
              params['tags']['entities'][i] = {};
              params['tags']['entities'][i]['tag'] = args.tags.entities[i].tag;
            }
          }
        }
        params['retry'] = args.retry;
        params['all'] = args.all;
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Application',
        request: 'ResolveUnitErrors',
        version: 6,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ErrorResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#ErrorResult
            if (resp['results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    Set implements the server side of Application.Set. It does not unset values
    that are set to an empty string. Unset should be used for that.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          application: string,
          options: map[string]string
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error or null if the operation succeeded.
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  set(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#ApplicationSet
      if (args) {
        params = {};
        params['application'] = args.application;
        params['options'] = {};
        args.options = args.options || {};
        for (let k in args.options) {
          params['options'][k] = args.options[k];
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Application',
        request: 'Set',
        version: 6,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    SetApplicationsConfig implements the server side of
    Application.SetApplicationsConfig. It does not unset values that are
    set to an empty string. Unset should be used for that.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          args: []{
            application: string,
            config: map[string]string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  setApplicationsConfig(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#ApplicationConfigSetArgs
      if (args) {
        params = {};
        params['Args'] = [];
        args.args = args.args || [];
        for (let i = 0; i < args.args.length; i++) {
          // github.com/juju/juju/apiserver/params#ApplicationConfigSet
          if (args.args[i]) {
            params['Args'][i] = {};
            params['Args'][i]['application'] = args.args[i].application;
            params['Args'][i]['config'] = {};
            args.args[i].config = args.args[i].config || {};
            for (let k in args.args[i].config) {
              params['Args'][i]['config'][k] = args.args[i].config[k];
            }
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Application',
        request: 'SetApplicationsConfig',
        version: 6,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ErrorResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#ErrorResult
            if (resp['results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    SetCharm sets the charm for a given for the application.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          application: string,
          charmUrl: string,
          channel: string,
          configSettings: map[string]string,
          configSettingsYaml: string,
          force: bool,
          forceUnits: bool,
          forceSeries: bool,
          resourceIds: map[string]string,
          storageConstraints: map[string]{
            pool: string,
            size: int,
            count: int
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error or null if the operation succeeded.
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  setCharm(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#ApplicationSetCharm
      if (args) {
        params = {};
        params['application'] = args.application;
        params['charm-url'] = args.charmUrl;
        params['channel'] = args.channel;
        params['config-settings'] = {};
        args.configSettings = args.configSettings || {};
        for (let k in args.configSettings) {
          params['config-settings'][k] = args.configSettings[k];
        }
        params['config-settings-yaml'] = args.configSettingsYaml;
        params['force'] = args.force;
        params['force-units'] = args.forceUnits;
        params['force-series'] = args.forceSeries;
        params['resource-ids'] = {};
        args.resourceIds = args.resourceIds || {};
        for (let k in args.resourceIds) {
          params['resource-ids'][k] = args.resourceIds[k];
        }
        params['storage-constraints'] = {};
        args.storageConstraints = args.storageConstraints || {};
        for (let k in args.storageConstraints) {
          // github.com/juju/juju/apiserver/params#StorageConstraints
          if (args.storageConstraints[k]) {
            params['storage-constraints'][k] = {};
            params['storage-constraints'][k]['pool'] = args.storageConstraints[k].pool;
            params['storage-constraints'][k]['size'] = args.storageConstraints[k].size;
            params['storage-constraints'][k]['count'] = args.storageConstraints[k].count;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Application',
        request: 'SetCharm',
        version: 6,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    SetCharmProfile a new charm's url on deployed machines for changing the
    profile used on those machine.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          application: string,
          charmUrl: string
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error or null if the operation succeeded.
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  setCharmProfile(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#ApplicationSetCharmProfile
      if (args) {
        params = {};
        params['application'] = args.application;
        params['charm-url'] = args.charmUrl;
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Application',
        request: 'SetCharmProfile',
        version: 6,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    SetConstraints sets the constraints for a given application.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          application: string,
          constraints: {
            arch: string,
            container: string,
            cores: int,
            cpuPower: int,
            mem: int,
            rootDisk: int,
            tags: []string,
            instanceType: string,
            spaces: []string,
            virtType: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error or null if the operation succeeded.
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  setConstraints(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#SetConstraints
      if (args) {
        params = {};
        params['application'] = args.application;
        // github.com/juju/juju/constraints#Value
        if (args.constraints) {
          params['constraints'] = {};
          params['constraints']['arch'] = args.constraints.arch;
          // github.com/juju/juju/instance#ContainerType
          params['constraints']['container'] = args.constraints.container;
          params['constraints']['cores'] = args.constraints.cores;
          params['constraints']['cpu-power'] = args.constraints.cpuPower;
          params['constraints']['mem'] = args.constraints.mem;
          params['constraints']['root-disk'] = args.constraints.rootDisk;
          params['constraints']['tags'] = [];
          args.constraints.tags = args.constraints.tags || [];
          for (let i = 0; i < args.constraints.tags.length; i++) {
            params['constraints']['tags'][i] = args.constraints.tags[i];
          }
          params['constraints']['instance-type'] = args.constraints.instanceType;
          params['constraints']['spaces'] = [];
          args.constraints.spaces = args.constraints.spaces || [];
          for (let i = 0; i < args.constraints.spaces.length; i++) {
            params['constraints']['spaces'][i] = args.constraints.spaces[i];
          }
          params['constraints']['virt-type'] = args.constraints.virtType;
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Application',
        request: 'SetConstraints',
        version: 6,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    SetMetricCredentials sets credentials on the application.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          creds: []{
            application: string,
            metricsCredentials: []int
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  setMetricCredentials(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#ApplicationMetricCredentials
      if (args) {
        params = {};
        params['creds'] = [];
        args.creds = args.creds || [];
        for (let i = 0; i < args.creds.length; i++) {
          // github.com/juju/juju/apiserver/params#ApplicationMetricCredential
          if (args.creds[i]) {
            params['creds'][i] = {};
            params['creds'][i]['application'] = args.creds[i].application;
            params['creds'][i]['metrics-credentials'] = [];
            args.creds[i].metricsCredentials = args.creds[i].metricsCredentials || [];
            for (let i2 = 0; i2 < args.creds[i].metricsCredentials.length; i2++) {
              params['creds'][i]['metrics-credentials'][i2] = args.creds[i].metricsCredentials[i2];
            }
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Application',
        request: 'SetMetricCredentials',
        version: 6,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ErrorResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#ErrorResult
            if (resp['results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    SetRelationsSuspended sets the suspended status of the specified relations.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          args: []{
            relationId: int,
            message: string,
            suspended: bool
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  setRelationsSuspended(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#RelationSuspendedArgs
      if (args) {
        params = {};
        params['args'] = [];
        args.args = args.args || [];
        for (let i = 0; i < args.args.length; i++) {
          // github.com/juju/juju/apiserver/params#RelationSuspendedArg
          if (args.args[i]) {
            params['args'][i] = {};
            params['args'][i]['relation-id'] = args.args[i].relationId;
            params['args'][i]['message'] = args.args[i].message;
            params['args'][i]['suspended'] = args.args[i].suspended;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Application',
        request: 'SetRelationsSuspended',
        version: 6,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ErrorResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#ErrorResult
            if (resp['results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    Unexpose changes the juju-managed firewall to unexpose any ports that were
    also explicitly marked by units as open.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          application: string
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error or null if the operation succeeded.
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  unexpose(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#ApplicationUnexpose
      if (args) {
        params = {};
        params['application'] = args.application;
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Application',
        request: 'Unexpose',
        version: 6,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    Unset implements the server side of Client.Unset.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          application: string,
          options: []string
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error or null if the operation succeeded.
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  unset(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#ApplicationUnset
      if (args) {
        params = {};
        params['application'] = args.application;
        params['options'] = [];
        args.options = args.options || [];
        for (let i = 0; i < args.options.length; i++) {
          params['options'][i] = args.options[i];
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Application',
        request: 'Unset',
        version: 6,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    UnsetApplicationsConfig implements the server side of
    Application.UnsetApplicationsConfig.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          args: []{
            application: string,
            options: []string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  unsetApplicationsConfig(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#ApplicationConfigUnsetArgs
      if (args) {
        params = {};
        params['Args'] = [];
        args.args = args.args || [];
        for (let i = 0; i < args.args.length; i++) {
          // github.com/juju/juju/apiserver/params#ApplicationUnset
          if (args.args[i]) {
            params['Args'][i] = {};
            params['Args'][i]['application'] = args.args[i].application;
            params['Args'][i]['options'] = [];
            args.args[i].options = args.args[i].options || [];
            for (let i2 = 0; i2 < args.args[i].options.length; i2++) {
              params['Args'][i]['options'][i2] = args.args[i].options[i2];
            }
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Application',
        request: 'UnsetApplicationsConfig',
        version: 6,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ErrorResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#ErrorResult
            if (resp['results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    Update updates the application attributes, including charm URL, minimum
    number of units, charm config and constraints. All parameters in
    params.ApplicationUpdate except the application name are optional.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          application: string,
          charmUrl: string,
          forceCharmUrl: bool,
          forceSeries: bool,
          force: bool,
          minUnits: int,
          settings: map[string]string,
          settingsYaml: string,
          constraints: {
            arch: string,
            container: string,
            cores: int,
            cpuPower: int,
            mem: int,
            rootDisk: int,
            tags: []string,
            instanceType: string,
            spaces: []string,
            virtType: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error or null if the operation succeeded.
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  update(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#ApplicationUpdate
      if (args) {
        params = {};
        params['application'] = args.application;
        params['charm-url'] = args.charmUrl;
        params['force-charm-url'] = args.forceCharmUrl;
        params['force-series'] = args.forceSeries;
        params['force'] = args.force;
        params['min-units'] = args.minUnits;
        params['settings'] = {};
        args.settings = args.settings || {};
        for (let k in args.settings) {
          params['settings'][k] = args.settings[k];
        }
        params['settings-yaml'] = args.settingsYaml;
        // github.com/juju/juju/constraints#Value
        if (args.constraints) {
          params['constraints'] = {};
          params['constraints']['arch'] = args.constraints.arch;
          // github.com/juju/juju/instance#ContainerType
          params['constraints']['container'] = args.constraints.container;
          params['constraints']['cores'] = args.constraints.cores;
          params['constraints']['cpu-power'] = args.constraints.cpuPower;
          params['constraints']['mem'] = args.constraints.mem;
          params['constraints']['root-disk'] = args.constraints.rootDisk;
          params['constraints']['tags'] = [];
          args.constraints.tags = args.constraints.tags || [];
          for (let i = 0; i < args.constraints.tags.length; i++) {
            params['constraints']['tags'][i] = args.constraints.tags[i];
          }
          params['constraints']['instance-type'] = args.constraints.instanceType;
          params['constraints']['spaces'] = [];
          args.constraints.spaces = args.constraints.spaces || [];
          for (let i = 0; i < args.constraints.spaces.length; i++) {
            params['constraints']['spaces'][i] = args.constraints.spaces[i];
          }
          params['constraints']['virt-type'] = args.constraints.virtType;
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Application',
        request: 'Update',
        version: 6,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    UpdateApplicationSeries updates the application series. Series for
    subordinates updated too.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          args: []{
            tag: {
              tag: string
            },
            force: bool,
            series: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  updateApplicationSeries(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#UpdateSeriesArgs
      if (args) {
        params = {};
        params['args'] = [];
        args.args = args.args || [];
        for (let i = 0; i < args.args.length; i++) {
          // github.com/juju/juju/apiserver/params#UpdateSeriesArg
          if (args.args[i]) {
            params['args'][i] = {};
            // github.com/juju/juju/apiserver/params#Entity
            if (args.args[i].tag) {
              params['args'][i]['tag'] = {};
              params['args'][i]['tag']['tag'] = args.args[i].tag.tag;
            }
            params['args'][i]['force'] = args.args[i].force;
            params['args'][i]['series'] = args.args[i].series;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Application',
        request: 'UpdateApplicationSeries',
        version: 6,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ErrorResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#ErrorResult
            if (resp['results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    WatchLXDProfileUpgradeNotifications returns a watcher that fires on LXD
    profile events.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          tag: string
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          notifywatcherid: string,
          error: {
            message: string,
            code: string,
            info: {
              macaroon: anything,
              macaroonPath: string
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  watchLXDProfileUpgradeNotifications(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#Entity
      if (args) {
        params = {};
        params['tag'] = args.tag;
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Application',
        request: 'WatchLXDProfileUpgradeNotifications',
        version: 6,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#NotifyWatchResult
        if (resp) {
          result = {};
          result.notifywatcherid = resp['NotifyWatcherId'];
          // github.com/juju/juju/apiserver/params#Error
          if (resp['error']) {
            result.error = {};
            result.error.message = resp['error']['message'];
            result.error.code = resp['error']['code'];
            // github.com/juju/juju/apiserver/params#ErrorInfo
            if (resp['error']['info']) {
              result.error.info = {};
              // gopkg.in/macaroon.v2-unstable#Macaroon
              result.error.info.macaroon = resp['error']['info']['macaroon'];
              result.error.info.macaroonPath = resp['error']['info']['macaroon-path'];
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }
}


const wrappers = require('../wrappers.js');
if (wrappers.wrapApplication) {
  // Decorate the facade class in order to improve user experience.
  ApplicationV6 = wrappers.wrapApplication(ApplicationV6);
}

module.exports = ApplicationV6;