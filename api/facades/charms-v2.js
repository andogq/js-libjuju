/**
  Juju Charms version 2.
  This API facade is available on model connections.

  NOTE: this file has been generated by the generate command in js-libjuju
  on Fri 2018/11/09 14:32:38 UTC. Do not manually edit this file.
*/

'use strict';

const {createAsyncHandler} = require('../transform.js');

/**
  API implements the charms interface and is the concrete implementation of the
  API end point.
*/
class CharmsV2 {

  constructor(transport, info) {
    this._transport = transport;
    this._info = info;
    this.version = 2;
  }

  /**
    CharmInfo returns information about the requested charm. NOTE: thumper
    2016-06-29, this is not a bulk call and probably should be.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          url: string
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          revision: int,
          url: string,
          config: map[string]{
            type: string,
            description: string,
            default: anything
          },
          meta: {
            name: string,
            summary: string,
            description: string,
            subordinate: bool,
            provides: map[string]{
              name: string,
              role: string,
              interface: string,
              optional: bool,
              limit: int,
              scope: string
            },
            requires: map[string]{
              name: string,
              role: string,
              interface: string,
              optional: bool,
              limit: int,
              scope: string
            },
            peers: map[string]{
              name: string,
              role: string,
              interface: string,
              optional: bool,
              limit: int,
              scope: string
            },
            extraBindings: map[string]string,
            categories: []string,
            tags: []string,
            series: []string,
            storage: map[string]{
              name: string,
              description: string,
              type: string,
              shared: bool,
              readOnly: bool,
              countMin: int,
              countMax: int,
              minimumSize: int,
              location: string,
              properties: []string
            },
            devices: map[string]{
              name: string,
              description: string,
              type: string,
              countmin: int,
              countmax: int
            },
            payloadClasses: map[string]{
              name: string,
              type: string
            },
            resources: map[string]{
              name: string,
              type: string,
              path: string,
              description: string
            },
            terms: []string,
            minJujuVersion: string
          },
          actions: {
            specs: map[string]{
              description: string,
              params: map[string]anything
            }
          },
          metrics: {
            metrics: map[string]{
              type: string,
              description: string
            },
            plan: {
              required: bool
            }
          },
          lxdProfile: {
            config: map[string]string,
            description: string,
            devices: map[string]map[string]string
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  charmInfo(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#CharmURL
      if (args) {
        params = {};
        params['url'] = args.url;
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Charms',
        request: 'CharmInfo',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#CharmInfo
        if (resp) {
          result = {};
          result.revision = resp['revision'];
          result.url = resp['url'];
          result.config = {};
          resp['config'] = resp['config'] || {};
          for (let k in resp['config']) {
            // github.com/juju/juju/apiserver/params#CharmOption
            if (resp['config'][k]) {
              result.config[k] = {};
              result.config[k].type = resp['config'][k]['type'];
              result.config[k].description = resp['config'][k]['description'];
              result.config[k].default = resp['config'][k]['default'];
            }
          }
          // github.com/juju/juju/apiserver/params#CharmMeta
          if (resp['meta']) {
            result.meta = {};
            result.meta.name = resp['meta']['name'];
            result.meta.summary = resp['meta']['summary'];
            result.meta.description = resp['meta']['description'];
            result.meta.subordinate = resp['meta']['subordinate'];
            result.meta.provides = {};
            resp['meta']['provides'] = resp['meta']['provides'] || {};
            for (let k in resp['meta']['provides']) {
              // github.com/juju/juju/apiserver/params#CharmRelation
              if (resp['meta']['provides'][k]) {
                result.meta.provides[k] = {};
                result.meta.provides[k].name = resp['meta']['provides'][k]['name'];
                result.meta.provides[k].role = resp['meta']['provides'][k]['role'];
                result.meta.provides[k].interface = resp['meta']['provides'][k]['interface'];
                result.meta.provides[k].optional = resp['meta']['provides'][k]['optional'];
                result.meta.provides[k].limit = resp['meta']['provides'][k]['limit'];
                result.meta.provides[k].scope = resp['meta']['provides'][k]['scope'];
              }
            }
            result.meta.requires = {};
            resp['meta']['requires'] = resp['meta']['requires'] || {};
            for (let k in resp['meta']['requires']) {
              // github.com/juju/juju/apiserver/params#CharmRelation
              if (resp['meta']['requires'][k]) {
                result.meta.requires[k] = {};
                result.meta.requires[k].name = resp['meta']['requires'][k]['name'];
                result.meta.requires[k].role = resp['meta']['requires'][k]['role'];
                result.meta.requires[k].interface = resp['meta']['requires'][k]['interface'];
                result.meta.requires[k].optional = resp['meta']['requires'][k]['optional'];
                result.meta.requires[k].limit = resp['meta']['requires'][k]['limit'];
                result.meta.requires[k].scope = resp['meta']['requires'][k]['scope'];
              }
            }
            result.meta.peers = {};
            resp['meta']['peers'] = resp['meta']['peers'] || {};
            for (let k in resp['meta']['peers']) {
              // github.com/juju/juju/apiserver/params#CharmRelation
              if (resp['meta']['peers'][k]) {
                result.meta.peers[k] = {};
                result.meta.peers[k].name = resp['meta']['peers'][k]['name'];
                result.meta.peers[k].role = resp['meta']['peers'][k]['role'];
                result.meta.peers[k].interface = resp['meta']['peers'][k]['interface'];
                result.meta.peers[k].optional = resp['meta']['peers'][k]['optional'];
                result.meta.peers[k].limit = resp['meta']['peers'][k]['limit'];
                result.meta.peers[k].scope = resp['meta']['peers'][k]['scope'];
              }
            }
            result.meta.extraBindings = {};
            resp['meta']['extra-bindings'] = resp['meta']['extra-bindings'] || {};
            for (let k in resp['meta']['extra-bindings']) {
              result.meta.extraBindings[k] = resp['meta']['extra-bindings'][k];
            }
            result.meta.categories = [];
            resp['meta']['categories'] = resp['meta']['categories'] || [];
            for (let i = 0; i < resp['meta']['categories'].length; i++) {
              result.meta.categories[i] = resp['meta']['categories'][i];
            }
            result.meta.tags = [];
            resp['meta']['tags'] = resp['meta']['tags'] || [];
            for (let i = 0; i < resp['meta']['tags'].length; i++) {
              result.meta.tags[i] = resp['meta']['tags'][i];
            }
            result.meta.series = [];
            resp['meta']['series'] = resp['meta']['series'] || [];
            for (let i = 0; i < resp['meta']['series'].length; i++) {
              result.meta.series[i] = resp['meta']['series'][i];
            }
            result.meta.storage = {};
            resp['meta']['storage'] = resp['meta']['storage'] || {};
            for (let k in resp['meta']['storage']) {
              // github.com/juju/juju/apiserver/params#CharmStorage
              if (resp['meta']['storage'][k]) {
                result.meta.storage[k] = {};
                result.meta.storage[k].name = resp['meta']['storage'][k]['name'];
                result.meta.storage[k].description = resp['meta']['storage'][k]['description'];
                result.meta.storage[k].type = resp['meta']['storage'][k]['type'];
                result.meta.storage[k].shared = resp['meta']['storage'][k]['shared'];
                result.meta.storage[k].readOnly = resp['meta']['storage'][k]['read-only'];
                result.meta.storage[k].countMin = resp['meta']['storage'][k]['count-min'];
                result.meta.storage[k].countMax = resp['meta']['storage'][k]['count-max'];
                result.meta.storage[k].minimumSize = resp['meta']['storage'][k]['minimum-size'];
                result.meta.storage[k].location = resp['meta']['storage'][k]['location'];
                result.meta.storage[k].properties = [];
                resp['meta']['storage'][k]['properties'] = resp['meta']['storage'][k]['properties'] || [];
                for (let i = 0; i < resp['meta']['storage'][k]['properties'].length; i++) {
                  result.meta.storage[k].properties[i] = resp['meta']['storage'][k]['properties'][i];
                }
              }
            }
            result.meta.devices = {};
            resp['meta']['devices'] = resp['meta']['devices'] || {};
            for (let k in resp['meta']['devices']) {
              // github.com/juju/juju/apiserver/params#CharmDevice
              if (resp['meta']['devices'][k]) {
                result.meta.devices[k] = {};
                result.meta.devices[k].name = resp['meta']['devices'][k]['Name'];
                result.meta.devices[k].description = resp['meta']['devices'][k]['Description'];
                result.meta.devices[k].type = resp['meta']['devices'][k]['Type'];
                result.meta.devices[k].countmin = resp['meta']['devices'][k]['CountMin'];
                result.meta.devices[k].countmax = resp['meta']['devices'][k]['CountMax'];
              }
            }
            result.meta.payloadClasses = {};
            resp['meta']['payload-classes'] = resp['meta']['payload-classes'] || {};
            for (let k in resp['meta']['payload-classes']) {
              // github.com/juju/juju/apiserver/params#CharmPayloadClass
              if (resp['meta']['payload-classes'][k]) {
                result.meta.payloadClasses[k] = {};
                result.meta.payloadClasses[k].name = resp['meta']['payload-classes'][k]['name'];
                result.meta.payloadClasses[k].type = resp['meta']['payload-classes'][k]['type'];
              }
            }
            result.meta.resources = {};
            resp['meta']['resources'] = resp['meta']['resources'] || {};
            for (let k in resp['meta']['resources']) {
              // github.com/juju/juju/apiserver/params#CharmResourceMeta
              if (resp['meta']['resources'][k]) {
                result.meta.resources[k] = {};
                result.meta.resources[k].name = resp['meta']['resources'][k]['name'];
                result.meta.resources[k].type = resp['meta']['resources'][k]['type'];
                result.meta.resources[k].path = resp['meta']['resources'][k]['path'];
                result.meta.resources[k].description = resp['meta']['resources'][k]['description'];
              }
            }
            result.meta.terms = [];
            resp['meta']['terms'] = resp['meta']['terms'] || [];
            for (let i = 0; i < resp['meta']['terms'].length; i++) {
              result.meta.terms[i] = resp['meta']['terms'][i];
            }
            result.meta.minJujuVersion = resp['meta']['min-juju-version'];
          }
          // github.com/juju/juju/apiserver/params#CharmActions
          if (resp['actions']) {
            result.actions = {};
            result.actions.specs = {};
            resp['actions']['specs'] = resp['actions']['specs'] || {};
            for (let k in resp['actions']['specs']) {
              // github.com/juju/juju/apiserver/params#CharmActionSpec
              if (resp['actions']['specs'][k]) {
                result.actions.specs[k] = {};
                result.actions.specs[k].description = resp['actions']['specs'][k]['description'];
                result.actions.specs[k].params = {};
                resp['actions']['specs'][k]['params'] = resp['actions']['specs'][k]['params'] || {};
                for (let k2 in resp['actions']['specs'][k]['params']) {
                  result.actions.specs[k].params[k2] = resp['actions']['specs'][k]['params'][k2];
                }
              }
            }
          }
          // github.com/juju/juju/apiserver/params#CharmMetrics
          if (resp['metrics']) {
            result.metrics = {};
            result.metrics.metrics = {};
            resp['metrics']['metrics'] = resp['metrics']['metrics'] || {};
            for (let k in resp['metrics']['metrics']) {
              // github.com/juju/juju/apiserver/params#CharmMetric
              if (resp['metrics']['metrics'][k]) {
                result.metrics.metrics[k] = {};
                result.metrics.metrics[k].type = resp['metrics']['metrics'][k]['type'];
                result.metrics.metrics[k].description = resp['metrics']['metrics'][k]['description'];
              }
            }
            // github.com/juju/juju/apiserver/params#CharmPlan
            if (resp['metrics']['plan']) {
              result.metrics.plan = {};
              result.metrics.plan.required = resp['metrics']['plan']['required'];
            }
          }
          // github.com/juju/juju/apiserver/params#CharmLXDProfile
          if (resp['lxd-profile']) {
            result.lxdProfile = {};
            result.lxdProfile.config = {};
            resp['lxd-profile']['config'] = resp['lxd-profile']['config'] || {};
            for (let k in resp['lxd-profile']['config']) {
              result.lxdProfile.config[k] = resp['lxd-profile']['config'][k];
            }
            result.lxdProfile.description = resp['lxd-profile']['description'];
            result.lxdProfile.devices = {};
            resp['lxd-profile']['devices'] = resp['lxd-profile']['devices'] || {};
            for (let k in resp['lxd-profile']['devices']) {
              result.lxdProfile.devices[k] = {};
              resp['lxd-profile']['devices'][k] = resp['lxd-profile']['devices'][k] || {};
              for (let k2 in resp['lxd-profile']['devices'][k]) {
                result.lxdProfile.devices[k][k2] = resp['lxd-profile']['devices'][k][k2];
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    IsMetered returns whether or not the charm is metered.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          url: string
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          metered: bool
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  isMetered(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#CharmURL
      if (args) {
        params = {};
        params['url'] = args.url;
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Charms',
        request: 'IsMetered',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#IsMeteredResult
        if (resp) {
          result = {};
          result.metered = resp['metered'];
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    List returns a list of charm URLs currently in the state. If supplied
    parameter contains any names, the result will be filtered to return
    only the charms with supplied names.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          names: []string
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          charmUrls: []string
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  list(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#CharmsList
      if (args) {
        params = {};
        params['names'] = [];
        args.names = args.names || [];
        for (let i = 0; i < args.names.length; i++) {
          params['names'][i] = args.names[i];
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Charms',
        request: 'List',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#CharmsListResult
        if (resp) {
          result = {};
          result.charmUrls = [];
          resp['charm-urls'] = resp['charm-urls'] || [];
          for (let i = 0; i < resp['charm-urls'].length; i++) {
            result.charmUrls[i] = resp['charm-urls'][i];
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }
}


const wrappers = require('../wrappers.js');
if (wrappers.wrapCharms) {
  // Decorate the facade class in order to improve user experience.
  CharmsV2 = wrappers.wrapCharms(CharmsV2);
}

module.exports = CharmsV2;