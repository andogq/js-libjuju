/**
  Juju Action version 2.
  This API facade is available on model connections.

  NOTE: this file has been generated by the generate command in js-libjuju
  on Fri 2018/11/16 13:11:58 UTC. Do not manually edit this file.
*/

'use strict';

const {autoBind, createAsyncHandler} = require('../transform.js');

/**
  ActionAPI implements the client API for interacting with Actions
*/
class ActionV2 {

  constructor(transport, info) {
    this._transport = transport;
    this._info = info;
    this.version = 2;

    // Automatically bind all methods to instances.
    autoBind(this);
  }

  /**
    Actions takes a list of ActionTags, and returns the full Action for each
    ID.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          entities: []{
            tag: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            action: {
              tag: string,
              receiver: string,
              name: string,
              parameters: map[string]anything
            },
            enqueued: time,
            started: time,
            completed: time,
            status: string,
            message: string,
            output: map[string]anything,
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  actions(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#Entities
      if (args) {
        params = {};
        params['entities'] = [];
        args.entities = args.entities || [];
        for (let i = 0; i < args.entities.length; i++) {
          // github.com/juju/juju/apiserver/params#Entity
          if (args.entities[i]) {
            params['entities'][i] = {};
            params['entities'][i]['tag'] = args.entities[i].tag;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Action',
        request: 'Actions',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ActionResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#ActionResult
            if (resp['results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/apiserver/params#Action
              if (resp['results'][i]['action']) {
                result.results[i].action = {};
                result.results[i].action.tag = resp['results'][i]['action']['tag'];
                result.results[i].action.receiver = resp['results'][i]['action']['receiver'];
                result.results[i].action.name = resp['results'][i]['action']['name'];
                result.results[i].action.parameters = {};
                resp['results'][i]['action']['parameters'] = resp['results'][i]['action']['parameters'] || {};
                for (let k in resp['results'][i]['action']['parameters']) {
                  result.results[i].action.parameters[k] = resp['results'][i]['action']['parameters'][k];
                }
              }
              // time#Time
              result.results[i].enqueued = resp['results'][i]['enqueued'];
              // time#Time
              result.results[i].started = resp['results'][i]['started'];
              // time#Time
              result.results[i].completed = resp['results'][i]['completed'];
              result.results[i].status = resp['results'][i]['status'];
              result.results[i].message = resp['results'][i]['message'];
              result.results[i].output = {};
              resp['results'][i]['output'] = resp['results'][i]['output'] || {};
              for (let k in resp['results'][i]['output']) {
                result.results[i].output[k] = resp['results'][i]['output'][k];
              }
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    ApplicationsCharmsActions returns a slice of charm Actions for a slice of
    services.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          entities: []{
            tag: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            applicationTag: string,
            actions: map[string]{
              description: string,
              params: map[string]anything
            },
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  applicationsCharmsActions(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#Entities
      if (args) {
        params = {};
        params['entities'] = [];
        args.entities = args.entities || [];
        for (let i = 0; i < args.entities.length; i++) {
          // github.com/juju/juju/apiserver/params#Entity
          if (args.entities[i]) {
            params['entities'][i] = {};
            params['entities'][i]['tag'] = args.entities[i].tag;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Action',
        request: 'ApplicationsCharmsActions',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ApplicationsCharmActionsResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#ApplicationCharmActionsResult
            if (resp['results'][i]) {
              result.results[i] = {};
              result.results[i].applicationTag = resp['results'][i]['application-tag'];
              result.results[i].actions = {};
              resp['results'][i]['actions'] = resp['results'][i]['actions'] || {};
              for (let k in resp['results'][i]['actions']) {
                // github.com/juju/juju/apiserver/params#ActionSpec
                if (resp['results'][i]['actions'][k]) {
                  result.results[i].actions[k] = {};
                  result.results[i].actions[k].description = resp['results'][i]['actions'][k]['description'];
                  result.results[i].actions[k].params = {};
                  resp['results'][i]['actions'][k]['params'] = resp['results'][i]['actions'][k]['params'] || {};
                  for (let k2 in resp['results'][i]['actions'][k]['params']) {
                    result.results[i].actions[k].params[k2] = resp['results'][i]['actions'][k]['params'][k2];
                  }
                }
              }
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    Cancel attempts to cancel enqueued Actions from running.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          entities: []{
            tag: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            action: {
              tag: string,
              receiver: string,
              name: string,
              parameters: map[string]anything
            },
            enqueued: time,
            started: time,
            completed: time,
            status: string,
            message: string,
            output: map[string]anything,
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  cancel(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#Entities
      if (args) {
        params = {};
        params['entities'] = [];
        args.entities = args.entities || [];
        for (let i = 0; i < args.entities.length; i++) {
          // github.com/juju/juju/apiserver/params#Entity
          if (args.entities[i]) {
            params['entities'][i] = {};
            params['entities'][i]['tag'] = args.entities[i].tag;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Action',
        request: 'Cancel',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ActionResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#ActionResult
            if (resp['results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/apiserver/params#Action
              if (resp['results'][i]['action']) {
                result.results[i].action = {};
                result.results[i].action.tag = resp['results'][i]['action']['tag'];
                result.results[i].action.receiver = resp['results'][i]['action']['receiver'];
                result.results[i].action.name = resp['results'][i]['action']['name'];
                result.results[i].action.parameters = {};
                resp['results'][i]['action']['parameters'] = resp['results'][i]['action']['parameters'] || {};
                for (let k in resp['results'][i]['action']['parameters']) {
                  result.results[i].action.parameters[k] = resp['results'][i]['action']['parameters'][k];
                }
              }
              // time#Time
              result.results[i].enqueued = resp['results'][i]['enqueued'];
              // time#Time
              result.results[i].started = resp['results'][i]['started'];
              // time#Time
              result.results[i].completed = resp['results'][i]['completed'];
              result.results[i].status = resp['results'][i]['status'];
              result.results[i].message = resp['results'][i]['message'];
              result.results[i].output = {};
              resp['results'][i]['output'] = resp['results'][i]['output'] || {};
              for (let k in resp['results'][i]['output']) {
                result.results[i].output[k] = resp['results'][i]['output'][k];
              }
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    Enqueue takes a list of Actions and queues them up to be executed by the
    designated ActionReceiver, returning the params.Action for each
    enqueued Action, or an error if there was a problem enqueueing the
    Action.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          actions: []{
            tag: string,
            receiver: string,
            name: string,
            parameters: map[string]anything
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            action: {
              tag: string,
              receiver: string,
              name: string,
              parameters: map[string]anything
            },
            enqueued: time,
            started: time,
            completed: time,
            status: string,
            message: string,
            output: map[string]anything,
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  enqueue(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#Actions
      if (args) {
        params = {};
        params['actions'] = [];
        args.actions = args.actions || [];
        for (let i = 0; i < args.actions.length; i++) {
          // github.com/juju/juju/apiserver/params#Action
          if (args.actions[i]) {
            params['actions'][i] = {};
            params['actions'][i]['tag'] = args.actions[i].tag;
            params['actions'][i]['receiver'] = args.actions[i].receiver;
            params['actions'][i]['name'] = args.actions[i].name;
            params['actions'][i]['parameters'] = {};
            args.actions[i].parameters = args.actions[i].parameters || {};
            for (let k in args.actions[i].parameters) {
              params['actions'][i]['parameters'][k] = args.actions[i].parameters[k];
            }
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Action',
        request: 'Enqueue',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ActionResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#ActionResult
            if (resp['results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/apiserver/params#Action
              if (resp['results'][i]['action']) {
                result.results[i].action = {};
                result.results[i].action.tag = resp['results'][i]['action']['tag'];
                result.results[i].action.receiver = resp['results'][i]['action']['receiver'];
                result.results[i].action.name = resp['results'][i]['action']['name'];
                result.results[i].action.parameters = {};
                resp['results'][i]['action']['parameters'] = resp['results'][i]['action']['parameters'] || {};
                for (let k in resp['results'][i]['action']['parameters']) {
                  result.results[i].action.parameters[k] = resp['results'][i]['action']['parameters'][k];
                }
              }
              // time#Time
              result.results[i].enqueued = resp['results'][i]['enqueued'];
              // time#Time
              result.results[i].started = resp['results'][i]['started'];
              // time#Time
              result.results[i].completed = resp['results'][i]['completed'];
              result.results[i].status = resp['results'][i]['status'];
              result.results[i].message = resp['results'][i]['message'];
              result.results[i].output = {};
              resp['results'][i]['output'] = resp['results'][i]['output'] || {};
              for (let k in resp['results'][i]['output']) {
                result.results[i].output[k] = resp['results'][i]['output'][k];
              }
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    FindActionTagsByPrefix takes a list of string prefixes and finds
    corresponding ActionTags that match that prefix.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          prefixes: []string
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          matches: map[string][]{
            tag: string
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  findActionTagsByPrefix(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#FindTags
      if (args) {
        params = {};
        params['prefixes'] = [];
        args.prefixes = args.prefixes || [];
        for (let i = 0; i < args.prefixes.length; i++) {
          params['prefixes'][i] = args.prefixes[i];
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Action',
        request: 'FindActionTagsByPrefix',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#FindTagsResults
        if (resp) {
          result = {};
          result.matches = {};
          resp['matches'] = resp['matches'] || {};
          for (let k in resp['matches']) {
            result.matches[k] = [];
            resp['matches'][k] = resp['matches'][k] || [];
            for (let i = 0; i < resp['matches'][k].length; i++) {
              // github.com/juju/juju/apiserver/params#Entity
              if (resp['matches'][k][i]) {
                result.matches[k][i] = {};
                result.matches[k][i].tag = resp['matches'][k][i]['tag'];
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    There is no documentation for this method.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          names: []string
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          actions: []{
            name: string,
            actions: []{
              action: {
                tag: string,
                receiver: string,
                name: string,
                parameters: map[string]anything
              },
              enqueued: time,
              started: time,
              completed: time,
              status: string,
              message: string,
              output: map[string]anything,
              error: {
                message: string,
                code: string,
                info: {
                  macaroon: anything,
                  macaroonPath: string
                }
              }
            },
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  findActionsByNames(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#FindActionsByNames
      if (args) {
        params = {};
        params['names'] = [];
        args.names = args.names || [];
        for (let i = 0; i < args.names.length; i++) {
          params['names'][i] = args.names[i];
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Action',
        request: 'FindActionsByNames',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ActionsByNames
        if (resp) {
          result = {};
          result.actions = [];
          resp['actions'] = resp['actions'] || [];
          for (let i = 0; i < resp['actions'].length; i++) {
            // github.com/juju/juju/apiserver/params#ActionsByName
            if (resp['actions'][i]) {
              result.actions[i] = {};
              result.actions[i].name = resp['actions'][i]['name'];
              result.actions[i].actions = [];
              resp['actions'][i]['actions'] = resp['actions'][i]['actions'] || [];
              for (let i2 = 0; i2 < resp['actions'][i]['actions'].length; i2++) {
                // github.com/juju/juju/apiserver/params#ActionResult
                if (resp['actions'][i]['actions'][i2]) {
                  result.actions[i].actions[i2] = {};
                  // github.com/juju/juju/apiserver/params#Action
                  if (resp['actions'][i]['actions'][i2]['action']) {
                    result.actions[i].actions[i2].action = {};
                    result.actions[i].actions[i2].action.tag = resp['actions'][i]['actions'][i2]['action']['tag'];
                    result.actions[i].actions[i2].action.receiver = resp['actions'][i]['actions'][i2]['action']['receiver'];
                    result.actions[i].actions[i2].action.name = resp['actions'][i]['actions'][i2]['action']['name'];
                    result.actions[i].actions[i2].action.parameters = {};
                    resp['actions'][i]['actions'][i2]['action']['parameters'] = resp['actions'][i]['actions'][i2]['action']['parameters'] || {};
                    for (let k in resp['actions'][i]['actions'][i2]['action']['parameters']) {
                      result.actions[i].actions[i2].action.parameters[k] = resp['actions'][i]['actions'][i2]['action']['parameters'][k];
                    }
                  }
                  // time#Time
                  result.actions[i].actions[i2].enqueued = resp['actions'][i]['actions'][i2]['enqueued'];
                  // time#Time
                  result.actions[i].actions[i2].started = resp['actions'][i]['actions'][i2]['started'];
                  // time#Time
                  result.actions[i].actions[i2].completed = resp['actions'][i]['actions'][i2]['completed'];
                  result.actions[i].actions[i2].status = resp['actions'][i]['actions'][i2]['status'];
                  result.actions[i].actions[i2].message = resp['actions'][i]['actions'][i2]['message'];
                  result.actions[i].actions[i2].output = {};
                  resp['actions'][i]['actions'][i2]['output'] = resp['actions'][i]['actions'][i2]['output'] || {};
                  for (let k in resp['actions'][i]['actions'][i2]['output']) {
                    result.actions[i].actions[i2].output[k] = resp['actions'][i]['actions'][i2]['output'][k];
                  }
                  // github.com/juju/juju/apiserver/params#Error
                  if (resp['actions'][i]['actions'][i2]['error']) {
                    result.actions[i].actions[i2].error = {};
                    result.actions[i].actions[i2].error.message = resp['actions'][i]['actions'][i2]['error']['message'];
                    result.actions[i].actions[i2].error.code = resp['actions'][i]['actions'][i2]['error']['code'];
                    // github.com/juju/juju/apiserver/params#ErrorInfo
                    if (resp['actions'][i]['actions'][i2]['error']['info']) {
                      result.actions[i].actions[i2].error.info = {};
                      // gopkg.in/macaroon.v2-unstable#Macaroon
                      result.actions[i].actions[i2].error.info.macaroon = resp['actions'][i]['actions'][i2]['error']['info']['macaroon'];
                      result.actions[i].actions[i2].error.info.macaroonPath = resp['actions'][i]['actions'][i2]['error']['info']['macaroon-path'];
                    }
                  }
                }
              }
              // github.com/juju/juju/apiserver/params#Error
              if (resp['actions'][i]['error']) {
                result.actions[i].error = {};
                result.actions[i].error.message = resp['actions'][i]['error']['message'];
                result.actions[i].error.code = resp['actions'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['actions'][i]['error']['info']) {
                  result.actions[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.actions[i].error.info.macaroon = resp['actions'][i]['error']['info']['macaroon'];
                  result.actions[i].error.info.macaroonPath = resp['actions'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    ListAll takes a list of Entities representing ActionReceivers and returns
    all of the Actions that have been enqueued or run by each of those
    Entities.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          entities: []{
            tag: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          actions: []{
            receiver: string,
            actions: []{
              action: {
                tag: string,
                receiver: string,
                name: string,
                parameters: map[string]anything
              },
              enqueued: time,
              started: time,
              completed: time,
              status: string,
              message: string,
              output: map[string]anything,
              error: {
                message: string,
                code: string,
                info: {
                  macaroon: anything,
                  macaroonPath: string
                }
              }
            },
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  listAll(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#Entities
      if (args) {
        params = {};
        params['entities'] = [];
        args.entities = args.entities || [];
        for (let i = 0; i < args.entities.length; i++) {
          // github.com/juju/juju/apiserver/params#Entity
          if (args.entities[i]) {
            params['entities'][i] = {};
            params['entities'][i]['tag'] = args.entities[i].tag;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Action',
        request: 'ListAll',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ActionsByReceivers
        if (resp) {
          result = {};
          result.actions = [];
          resp['actions'] = resp['actions'] || [];
          for (let i = 0; i < resp['actions'].length; i++) {
            // github.com/juju/juju/apiserver/params#ActionsByReceiver
            if (resp['actions'][i]) {
              result.actions[i] = {};
              result.actions[i].receiver = resp['actions'][i]['receiver'];
              result.actions[i].actions = [];
              resp['actions'][i]['actions'] = resp['actions'][i]['actions'] || [];
              for (let i2 = 0; i2 < resp['actions'][i]['actions'].length; i2++) {
                // github.com/juju/juju/apiserver/params#ActionResult
                if (resp['actions'][i]['actions'][i2]) {
                  result.actions[i].actions[i2] = {};
                  // github.com/juju/juju/apiserver/params#Action
                  if (resp['actions'][i]['actions'][i2]['action']) {
                    result.actions[i].actions[i2].action = {};
                    result.actions[i].actions[i2].action.tag = resp['actions'][i]['actions'][i2]['action']['tag'];
                    result.actions[i].actions[i2].action.receiver = resp['actions'][i]['actions'][i2]['action']['receiver'];
                    result.actions[i].actions[i2].action.name = resp['actions'][i]['actions'][i2]['action']['name'];
                    result.actions[i].actions[i2].action.parameters = {};
                    resp['actions'][i]['actions'][i2]['action']['parameters'] = resp['actions'][i]['actions'][i2]['action']['parameters'] || {};
                    for (let k in resp['actions'][i]['actions'][i2]['action']['parameters']) {
                      result.actions[i].actions[i2].action.parameters[k] = resp['actions'][i]['actions'][i2]['action']['parameters'][k];
                    }
                  }
                  // time#Time
                  result.actions[i].actions[i2].enqueued = resp['actions'][i]['actions'][i2]['enqueued'];
                  // time#Time
                  result.actions[i].actions[i2].started = resp['actions'][i]['actions'][i2]['started'];
                  // time#Time
                  result.actions[i].actions[i2].completed = resp['actions'][i]['actions'][i2]['completed'];
                  result.actions[i].actions[i2].status = resp['actions'][i]['actions'][i2]['status'];
                  result.actions[i].actions[i2].message = resp['actions'][i]['actions'][i2]['message'];
                  result.actions[i].actions[i2].output = {};
                  resp['actions'][i]['actions'][i2]['output'] = resp['actions'][i]['actions'][i2]['output'] || {};
                  for (let k in resp['actions'][i]['actions'][i2]['output']) {
                    result.actions[i].actions[i2].output[k] = resp['actions'][i]['actions'][i2]['output'][k];
                  }
                  // github.com/juju/juju/apiserver/params#Error
                  if (resp['actions'][i]['actions'][i2]['error']) {
                    result.actions[i].actions[i2].error = {};
                    result.actions[i].actions[i2].error.message = resp['actions'][i]['actions'][i2]['error']['message'];
                    result.actions[i].actions[i2].error.code = resp['actions'][i]['actions'][i2]['error']['code'];
                    // github.com/juju/juju/apiserver/params#ErrorInfo
                    if (resp['actions'][i]['actions'][i2]['error']['info']) {
                      result.actions[i].actions[i2].error.info = {};
                      // gopkg.in/macaroon.v2-unstable#Macaroon
                      result.actions[i].actions[i2].error.info.macaroon = resp['actions'][i]['actions'][i2]['error']['info']['macaroon'];
                      result.actions[i].actions[i2].error.info.macaroonPath = resp['actions'][i]['actions'][i2]['error']['info']['macaroon-path'];
                    }
                  }
                }
              }
              // github.com/juju/juju/apiserver/params#Error
              if (resp['actions'][i]['error']) {
                result.actions[i].error = {};
                result.actions[i].error.message = resp['actions'][i]['error']['message'];
                result.actions[i].error.code = resp['actions'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['actions'][i]['error']['info']) {
                  result.actions[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.actions[i].error.info.macaroon = resp['actions'][i]['error']['info']['macaroon'];
                  result.actions[i].error.info.macaroonPath = resp['actions'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    ListCompleted takes a list of Entities representing ActionReceivers and
    returns all of the Actions that have been run on each of those
    Entities.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          entities: []{
            tag: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          actions: []{
            receiver: string,
            actions: []{
              action: {
                tag: string,
                receiver: string,
                name: string,
                parameters: map[string]anything
              },
              enqueued: time,
              started: time,
              completed: time,
              status: string,
              message: string,
              output: map[string]anything,
              error: {
                message: string,
                code: string,
                info: {
                  macaroon: anything,
                  macaroonPath: string
                }
              }
            },
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  listCompleted(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#Entities
      if (args) {
        params = {};
        params['entities'] = [];
        args.entities = args.entities || [];
        for (let i = 0; i < args.entities.length; i++) {
          // github.com/juju/juju/apiserver/params#Entity
          if (args.entities[i]) {
            params['entities'][i] = {};
            params['entities'][i]['tag'] = args.entities[i].tag;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Action',
        request: 'ListCompleted',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ActionsByReceivers
        if (resp) {
          result = {};
          result.actions = [];
          resp['actions'] = resp['actions'] || [];
          for (let i = 0; i < resp['actions'].length; i++) {
            // github.com/juju/juju/apiserver/params#ActionsByReceiver
            if (resp['actions'][i]) {
              result.actions[i] = {};
              result.actions[i].receiver = resp['actions'][i]['receiver'];
              result.actions[i].actions = [];
              resp['actions'][i]['actions'] = resp['actions'][i]['actions'] || [];
              for (let i2 = 0; i2 < resp['actions'][i]['actions'].length; i2++) {
                // github.com/juju/juju/apiserver/params#ActionResult
                if (resp['actions'][i]['actions'][i2]) {
                  result.actions[i].actions[i2] = {};
                  // github.com/juju/juju/apiserver/params#Action
                  if (resp['actions'][i]['actions'][i2]['action']) {
                    result.actions[i].actions[i2].action = {};
                    result.actions[i].actions[i2].action.tag = resp['actions'][i]['actions'][i2]['action']['tag'];
                    result.actions[i].actions[i2].action.receiver = resp['actions'][i]['actions'][i2]['action']['receiver'];
                    result.actions[i].actions[i2].action.name = resp['actions'][i]['actions'][i2]['action']['name'];
                    result.actions[i].actions[i2].action.parameters = {};
                    resp['actions'][i]['actions'][i2]['action']['parameters'] = resp['actions'][i]['actions'][i2]['action']['parameters'] || {};
                    for (let k in resp['actions'][i]['actions'][i2]['action']['parameters']) {
                      result.actions[i].actions[i2].action.parameters[k] = resp['actions'][i]['actions'][i2]['action']['parameters'][k];
                    }
                  }
                  // time#Time
                  result.actions[i].actions[i2].enqueued = resp['actions'][i]['actions'][i2]['enqueued'];
                  // time#Time
                  result.actions[i].actions[i2].started = resp['actions'][i]['actions'][i2]['started'];
                  // time#Time
                  result.actions[i].actions[i2].completed = resp['actions'][i]['actions'][i2]['completed'];
                  result.actions[i].actions[i2].status = resp['actions'][i]['actions'][i2]['status'];
                  result.actions[i].actions[i2].message = resp['actions'][i]['actions'][i2]['message'];
                  result.actions[i].actions[i2].output = {};
                  resp['actions'][i]['actions'][i2]['output'] = resp['actions'][i]['actions'][i2]['output'] || {};
                  for (let k in resp['actions'][i]['actions'][i2]['output']) {
                    result.actions[i].actions[i2].output[k] = resp['actions'][i]['actions'][i2]['output'][k];
                  }
                  // github.com/juju/juju/apiserver/params#Error
                  if (resp['actions'][i]['actions'][i2]['error']) {
                    result.actions[i].actions[i2].error = {};
                    result.actions[i].actions[i2].error.message = resp['actions'][i]['actions'][i2]['error']['message'];
                    result.actions[i].actions[i2].error.code = resp['actions'][i]['actions'][i2]['error']['code'];
                    // github.com/juju/juju/apiserver/params#ErrorInfo
                    if (resp['actions'][i]['actions'][i2]['error']['info']) {
                      result.actions[i].actions[i2].error.info = {};
                      // gopkg.in/macaroon.v2-unstable#Macaroon
                      result.actions[i].actions[i2].error.info.macaroon = resp['actions'][i]['actions'][i2]['error']['info']['macaroon'];
                      result.actions[i].actions[i2].error.info.macaroonPath = resp['actions'][i]['actions'][i2]['error']['info']['macaroon-path'];
                    }
                  }
                }
              }
              // github.com/juju/juju/apiserver/params#Error
              if (resp['actions'][i]['error']) {
                result.actions[i].error = {};
                result.actions[i].error.message = resp['actions'][i]['error']['message'];
                result.actions[i].error.code = resp['actions'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['actions'][i]['error']['info']) {
                  result.actions[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.actions[i].error.info.macaroon = resp['actions'][i]['error']['info']['macaroon'];
                  result.actions[i].error.info.macaroonPath = resp['actions'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    ListPending takes a list of Entities representing ActionReceivers and
    returns all of the Actions that are enqueued for each of those
    Entities.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          entities: []{
            tag: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          actions: []{
            receiver: string,
            actions: []{
              action: {
                tag: string,
                receiver: string,
                name: string,
                parameters: map[string]anything
              },
              enqueued: time,
              started: time,
              completed: time,
              status: string,
              message: string,
              output: map[string]anything,
              error: {
                message: string,
                code: string,
                info: {
                  macaroon: anything,
                  macaroonPath: string
                }
              }
            },
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  listPending(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#Entities
      if (args) {
        params = {};
        params['entities'] = [];
        args.entities = args.entities || [];
        for (let i = 0; i < args.entities.length; i++) {
          // github.com/juju/juju/apiserver/params#Entity
          if (args.entities[i]) {
            params['entities'][i] = {};
            params['entities'][i]['tag'] = args.entities[i].tag;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Action',
        request: 'ListPending',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ActionsByReceivers
        if (resp) {
          result = {};
          result.actions = [];
          resp['actions'] = resp['actions'] || [];
          for (let i = 0; i < resp['actions'].length; i++) {
            // github.com/juju/juju/apiserver/params#ActionsByReceiver
            if (resp['actions'][i]) {
              result.actions[i] = {};
              result.actions[i].receiver = resp['actions'][i]['receiver'];
              result.actions[i].actions = [];
              resp['actions'][i]['actions'] = resp['actions'][i]['actions'] || [];
              for (let i2 = 0; i2 < resp['actions'][i]['actions'].length; i2++) {
                // github.com/juju/juju/apiserver/params#ActionResult
                if (resp['actions'][i]['actions'][i2]) {
                  result.actions[i].actions[i2] = {};
                  // github.com/juju/juju/apiserver/params#Action
                  if (resp['actions'][i]['actions'][i2]['action']) {
                    result.actions[i].actions[i2].action = {};
                    result.actions[i].actions[i2].action.tag = resp['actions'][i]['actions'][i2]['action']['tag'];
                    result.actions[i].actions[i2].action.receiver = resp['actions'][i]['actions'][i2]['action']['receiver'];
                    result.actions[i].actions[i2].action.name = resp['actions'][i]['actions'][i2]['action']['name'];
                    result.actions[i].actions[i2].action.parameters = {};
                    resp['actions'][i]['actions'][i2]['action']['parameters'] = resp['actions'][i]['actions'][i2]['action']['parameters'] || {};
                    for (let k in resp['actions'][i]['actions'][i2]['action']['parameters']) {
                      result.actions[i].actions[i2].action.parameters[k] = resp['actions'][i]['actions'][i2]['action']['parameters'][k];
                    }
                  }
                  // time#Time
                  result.actions[i].actions[i2].enqueued = resp['actions'][i]['actions'][i2]['enqueued'];
                  // time#Time
                  result.actions[i].actions[i2].started = resp['actions'][i]['actions'][i2]['started'];
                  // time#Time
                  result.actions[i].actions[i2].completed = resp['actions'][i]['actions'][i2]['completed'];
                  result.actions[i].actions[i2].status = resp['actions'][i]['actions'][i2]['status'];
                  result.actions[i].actions[i2].message = resp['actions'][i]['actions'][i2]['message'];
                  result.actions[i].actions[i2].output = {};
                  resp['actions'][i]['actions'][i2]['output'] = resp['actions'][i]['actions'][i2]['output'] || {};
                  for (let k in resp['actions'][i]['actions'][i2]['output']) {
                    result.actions[i].actions[i2].output[k] = resp['actions'][i]['actions'][i2]['output'][k];
                  }
                  // github.com/juju/juju/apiserver/params#Error
                  if (resp['actions'][i]['actions'][i2]['error']) {
                    result.actions[i].actions[i2].error = {};
                    result.actions[i].actions[i2].error.message = resp['actions'][i]['actions'][i2]['error']['message'];
                    result.actions[i].actions[i2].error.code = resp['actions'][i]['actions'][i2]['error']['code'];
                    // github.com/juju/juju/apiserver/params#ErrorInfo
                    if (resp['actions'][i]['actions'][i2]['error']['info']) {
                      result.actions[i].actions[i2].error.info = {};
                      // gopkg.in/macaroon.v2-unstable#Macaroon
                      result.actions[i].actions[i2].error.info.macaroon = resp['actions'][i]['actions'][i2]['error']['info']['macaroon'];
                      result.actions[i].actions[i2].error.info.macaroonPath = resp['actions'][i]['actions'][i2]['error']['info']['macaroon-path'];
                    }
                  }
                }
              }
              // github.com/juju/juju/apiserver/params#Error
              if (resp['actions'][i]['error']) {
                result.actions[i].error = {};
                result.actions[i].error.message = resp['actions'][i]['error']['message'];
                result.actions[i].error.code = resp['actions'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['actions'][i]['error']['info']) {
                  result.actions[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.actions[i].error.info.macaroon = resp['actions'][i]['error']['info']['macaroon'];
                  result.actions[i].error.info.macaroonPath = resp['actions'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    ListRunning takes a list of Entities representing ActionReceivers and
    returns all of the Actions that have are running on each of those
    Entities.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          entities: []{
            tag: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          actions: []{
            receiver: string,
            actions: []{
              action: {
                tag: string,
                receiver: string,
                name: string,
                parameters: map[string]anything
              },
              enqueued: time,
              started: time,
              completed: time,
              status: string,
              message: string,
              output: map[string]anything,
              error: {
                message: string,
                code: string,
                info: {
                  macaroon: anything,
                  macaroonPath: string
                }
              }
            },
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  listRunning(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#Entities
      if (args) {
        params = {};
        params['entities'] = [];
        args.entities = args.entities || [];
        for (let i = 0; i < args.entities.length; i++) {
          // github.com/juju/juju/apiserver/params#Entity
          if (args.entities[i]) {
            params['entities'][i] = {};
            params['entities'][i]['tag'] = args.entities[i].tag;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Action',
        request: 'ListRunning',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ActionsByReceivers
        if (resp) {
          result = {};
          result.actions = [];
          resp['actions'] = resp['actions'] || [];
          for (let i = 0; i < resp['actions'].length; i++) {
            // github.com/juju/juju/apiserver/params#ActionsByReceiver
            if (resp['actions'][i]) {
              result.actions[i] = {};
              result.actions[i].receiver = resp['actions'][i]['receiver'];
              result.actions[i].actions = [];
              resp['actions'][i]['actions'] = resp['actions'][i]['actions'] || [];
              for (let i2 = 0; i2 < resp['actions'][i]['actions'].length; i2++) {
                // github.com/juju/juju/apiserver/params#ActionResult
                if (resp['actions'][i]['actions'][i2]) {
                  result.actions[i].actions[i2] = {};
                  // github.com/juju/juju/apiserver/params#Action
                  if (resp['actions'][i]['actions'][i2]['action']) {
                    result.actions[i].actions[i2].action = {};
                    result.actions[i].actions[i2].action.tag = resp['actions'][i]['actions'][i2]['action']['tag'];
                    result.actions[i].actions[i2].action.receiver = resp['actions'][i]['actions'][i2]['action']['receiver'];
                    result.actions[i].actions[i2].action.name = resp['actions'][i]['actions'][i2]['action']['name'];
                    result.actions[i].actions[i2].action.parameters = {};
                    resp['actions'][i]['actions'][i2]['action']['parameters'] = resp['actions'][i]['actions'][i2]['action']['parameters'] || {};
                    for (let k in resp['actions'][i]['actions'][i2]['action']['parameters']) {
                      result.actions[i].actions[i2].action.parameters[k] = resp['actions'][i]['actions'][i2]['action']['parameters'][k];
                    }
                  }
                  // time#Time
                  result.actions[i].actions[i2].enqueued = resp['actions'][i]['actions'][i2]['enqueued'];
                  // time#Time
                  result.actions[i].actions[i2].started = resp['actions'][i]['actions'][i2]['started'];
                  // time#Time
                  result.actions[i].actions[i2].completed = resp['actions'][i]['actions'][i2]['completed'];
                  result.actions[i].actions[i2].status = resp['actions'][i]['actions'][i2]['status'];
                  result.actions[i].actions[i2].message = resp['actions'][i]['actions'][i2]['message'];
                  result.actions[i].actions[i2].output = {};
                  resp['actions'][i]['actions'][i2]['output'] = resp['actions'][i]['actions'][i2]['output'] || {};
                  for (let k in resp['actions'][i]['actions'][i2]['output']) {
                    result.actions[i].actions[i2].output[k] = resp['actions'][i]['actions'][i2]['output'][k];
                  }
                  // github.com/juju/juju/apiserver/params#Error
                  if (resp['actions'][i]['actions'][i2]['error']) {
                    result.actions[i].actions[i2].error = {};
                    result.actions[i].actions[i2].error.message = resp['actions'][i]['actions'][i2]['error']['message'];
                    result.actions[i].actions[i2].error.code = resp['actions'][i]['actions'][i2]['error']['code'];
                    // github.com/juju/juju/apiserver/params#ErrorInfo
                    if (resp['actions'][i]['actions'][i2]['error']['info']) {
                      result.actions[i].actions[i2].error.info = {};
                      // gopkg.in/macaroon.v2-unstable#Macaroon
                      result.actions[i].actions[i2].error.info.macaroon = resp['actions'][i]['actions'][i2]['error']['info']['macaroon'];
                      result.actions[i].actions[i2].error.info.macaroonPath = resp['actions'][i]['actions'][i2]['error']['info']['macaroon-path'];
                    }
                  }
                }
              }
              // github.com/juju/juju/apiserver/params#Error
              if (resp['actions'][i]['error']) {
                result.actions[i].error = {};
                result.actions[i].error.message = resp['actions'][i]['error']['message'];
                result.actions[i].error.code = resp['actions'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['actions'][i]['error']['info']) {
                  result.actions[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.actions[i].error.info.macaroon = resp['actions'][i]['error']['info']['macaroon'];
                  result.actions[i].error.info.macaroonPath = resp['actions'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    Run the commands specified on the machines identified through the list of
    machines, units and services.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          commands: string,
          timeout: int,
          machines: []string,
          applications: []string,
          units: []string
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            action: {
              tag: string,
              receiver: string,
              name: string,
              parameters: map[string]anything
            },
            enqueued: time,
            started: time,
            completed: time,
            status: string,
            message: string,
            output: map[string]anything,
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  run(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#RunParams
      if (args) {
        params = {};
        params['commands'] = args.commands;
        // time#Duration
        params['timeout'] = args.timeout;
        params['machines'] = [];
        args.machines = args.machines || [];
        for (let i = 0; i < args.machines.length; i++) {
          params['machines'][i] = args.machines[i];
        }
        params['applications'] = [];
        args.applications = args.applications || [];
        for (let i = 0; i < args.applications.length; i++) {
          params['applications'][i] = args.applications[i];
        }
        params['units'] = [];
        args.units = args.units || [];
        for (let i = 0; i < args.units.length; i++) {
          params['units'][i] = args.units[i];
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Action',
        request: 'Run',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ActionResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#ActionResult
            if (resp['results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/apiserver/params#Action
              if (resp['results'][i]['action']) {
                result.results[i].action = {};
                result.results[i].action.tag = resp['results'][i]['action']['tag'];
                result.results[i].action.receiver = resp['results'][i]['action']['receiver'];
                result.results[i].action.name = resp['results'][i]['action']['name'];
                result.results[i].action.parameters = {};
                resp['results'][i]['action']['parameters'] = resp['results'][i]['action']['parameters'] || {};
                for (let k in resp['results'][i]['action']['parameters']) {
                  result.results[i].action.parameters[k] = resp['results'][i]['action']['parameters'][k];
                }
              }
              // time#Time
              result.results[i].enqueued = resp['results'][i]['enqueued'];
              // time#Time
              result.results[i].started = resp['results'][i]['started'];
              // time#Time
              result.results[i].completed = resp['results'][i]['completed'];
              result.results[i].status = resp['results'][i]['status'];
              result.results[i].message = resp['results'][i]['message'];
              result.results[i].output = {};
              resp['results'][i]['output'] = resp['results'][i]['output'] || {};
              for (let k in resp['results'][i]['output']) {
                result.results[i].output[k] = resp['results'][i]['output'][k];
              }
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    RunOnAllMachines attempts to run the specified command on all the machines.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          commands: string,
          timeout: int,
          machines: []string,
          applications: []string,
          units: []string
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            action: {
              tag: string,
              receiver: string,
              name: string,
              parameters: map[string]anything
            },
            enqueued: time,
            started: time,
            completed: time,
            status: string,
            message: string,
            output: map[string]anything,
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  runOnAllMachines(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#RunParams
      if (args) {
        params = {};
        params['commands'] = args.commands;
        // time#Duration
        params['timeout'] = args.timeout;
        params['machines'] = [];
        args.machines = args.machines || [];
        for (let i = 0; i < args.machines.length; i++) {
          params['machines'][i] = args.machines[i];
        }
        params['applications'] = [];
        args.applications = args.applications || [];
        for (let i = 0; i < args.applications.length; i++) {
          params['applications'][i] = args.applications[i];
        }
        params['units'] = [];
        args.units = args.units || [];
        for (let i = 0; i < args.units.length; i++) {
          params['units'][i] = args.units[i];
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Action',
        request: 'RunOnAllMachines',
        version: 2,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ActionResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#ActionResult
            if (resp['results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/apiserver/params#Action
              if (resp['results'][i]['action']) {
                result.results[i].action = {};
                result.results[i].action.tag = resp['results'][i]['action']['tag'];
                result.results[i].action.receiver = resp['results'][i]['action']['receiver'];
                result.results[i].action.name = resp['results'][i]['action']['name'];
                result.results[i].action.parameters = {};
                resp['results'][i]['action']['parameters'] = resp['results'][i]['action']['parameters'] || {};
                for (let k in resp['results'][i]['action']['parameters']) {
                  result.results[i].action.parameters[k] = resp['results'][i]['action']['parameters'][k];
                }
              }
              // time#Time
              result.results[i].enqueued = resp['results'][i]['enqueued'];
              // time#Time
              result.results[i].started = resp['results'][i]['started'];
              // time#Time
              result.results[i].completed = resp['results'][i]['completed'];
              result.results[i].status = resp['results'][i]['status'];
              result.results[i].message = resp['results'][i]['message'];
              result.results[i].output = {};
              resp['results'][i]['output'] = resp['results'][i]['output'] || {};
              for (let k in resp['results'][i]['output']) {
                result.results[i].output[k] = resp['results'][i]['output'][k];
              }
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }
}


const wrappers = require('../wrappers.js');
if (wrappers.wrapAction) {
  // Decorate the facade class in order to improve user experience.
  ActionV2 = wrappers.wrapAction(ActionV2);
}

module.exports = ActionV2;