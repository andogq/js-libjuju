/**
  Juju Admin version 3.
  This API facade is available on both controller and model connections.

  NOTE: this file has been generated by the generate command in js-libjuju
  on Tue 2018/11/27 16:23:14 UTC. Do not manually edit this file.
*/

'use strict';

const {autoBind, createAsyncHandler} = require('../transform.js');

/**
  admin is the only object that unlogged-in clients can access. It holds any
  methods that are needed to log in.
*/
class AdminV3 {

  constructor(transport, info) {
    this._transport = transport;
    this._info = info;
    this.version = 3;

    // Automatically bind all methods to instances.
    autoBind(this);
  }

  /**
    Login logs in with the provided credentials.  All subsequent requests on
    the connection will act as the authenticated user.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          authTag: string,
          credentials: string,
          nonce: string,
          macaroons: [][]anything,
          cliArgs: string,
          userData: string
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          dischargeRequired: anything,
          dischargeRequiredError: string,
          servers: [][]{
            address: {
              value: string,
              type: string,
              scope: string,
              spaceName: string
            },
            port: int
          },
          publicDnsName: string,
          modelTag: string,
          controllerTag: string,
          userInfo: {
            displayName: string,
            identity: string,
            lastConnection: time,
            credentials: string,
            controllerAccess: string,
            modelAccess: string
          },
          facades: []{
            name: string,
            versions: []int
          },
          serverVersion: string
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  login(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#LoginRequest
      if (args) {
        params = {};
        params['auth-tag'] = args.authTag;
        params['credentials'] = args.credentials;
        params['nonce'] = args.nonce;
        params['macaroons'] = [];
        args.macaroons = args.macaroons || [];
        for (let i = 0; i < args.macaroons.length; i++) {
          // gopkg.in/macaroon.v2-unstable#Slice
          params['macaroons'][i] = [];
          args.macaroons[i] = args.macaroons[i] || [];
          for (let i2 = 0; i2 < args.macaroons[i].length; i2++) {
            // gopkg.in/macaroon.v2-unstable#Macaroon
            params['macaroons'][i][i2] = args.macaroons[i][i2];
          }
        }
        params['cli-args'] = args.cliArgs;
        params['user-data'] = args.userData;
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Admin',
        request: 'Login',
        version: 3,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#LoginResult
        if (resp) {
          result = {};
          // gopkg.in/macaroon.v2-unstable#Macaroon
          result.dischargeRequired = resp['discharge-required'];
          result.dischargeRequiredError = resp['discharge-required-error'];
          result.servers = [];
          resp['servers'] = resp['servers'] || [];
          for (let i = 0; i < resp['servers'].length; i++) {
            result.servers[i] = [];
            resp['servers'][i] = resp['servers'][i] || [];
            for (let i2 = 0; i2 < resp['servers'][i].length; i2++) {
              // github.com/juju/juju/apiserver/params#HostPort
              if (resp['servers'][i][i2]) {
                result.servers[i][i2] = {};
                // github.com/juju/juju/apiserver/params#Address
                if (resp['servers'][i][i2]['Address']) {
                  result.servers[i][i2].address = {};
                  result.servers[i][i2].address.value = resp['servers'][i][i2]['Address']['value'];
                  result.servers[i][i2].address.type = resp['servers'][i][i2]['Address']['type'];
                  result.servers[i][i2].address.scope = resp['servers'][i][i2]['Address']['scope'];
                  result.servers[i][i2].address.spaceName = resp['servers'][i][i2]['Address']['space-name'];
                }
                result.servers[i][i2].port = resp['servers'][i][i2]['port'];
              }
            }
          }
          result.publicDnsName = resp['public-dns-name'];
          result.modelTag = resp['model-tag'];
          result.controllerTag = resp['controller-tag'];
          // github.com/juju/juju/apiserver/params#AuthUserInfo
          if (resp['user-info']) {
            result.userInfo = {};
            result.userInfo.displayName = resp['user-info']['display-name'];
            result.userInfo.identity = resp['user-info']['identity'];
            // time#Time
            result.userInfo.lastConnection = resp['user-info']['last-connection'];
            result.userInfo.credentials = resp['user-info']['credentials'];
            result.userInfo.controllerAccess = resp['user-info']['controller-access'];
            result.userInfo.modelAccess = resp['user-info']['model-access'];
          }
          result.facades = [];
          resp['facades'] = resp['facades'] || [];
          for (let i = 0; i < resp['facades'].length; i++) {
            // github.com/juju/juju/apiserver/params#FacadeVersions
            if (resp['facades'][i]) {
              result.facades[i] = {};
              result.facades[i].name = resp['facades'][i]['name'];
              result.facades[i].versions = [];
              resp['facades'][i]['versions'] = resp['facades'][i]['versions'] || [];
              for (let i2 = 0; i2 < resp['facades'][i]['versions'].length; i2++) {
                result.facades[i].versions[i2] = resp['facades'][i]['versions'][i2];
              }
            }
          }
          result.serverVersion = resp['server-version'];
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    RedirectInfo returns redirected host information for the model. In Juju it
    always returns an error because the Juju controller does not multiplex
    controllers.

    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          servers: [][]{
            address: {
              value: string,
              type: string,
              scope: string,
              spaceName: string
            },
            port: int
          },
          caCert: string
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  redirectInfo(callback) {
    return new Promise((resolve, reject) => {
      const params = {};
      // Prepare the request to the Juju API.
      const req = {
        type: 'Admin',
        request: 'RedirectInfo',
        version: 3,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#RedirectInfoResult
        if (resp) {
          result = {};
          result.servers = [];
          resp['servers'] = resp['servers'] || [];
          for (let i = 0; i < resp['servers'].length; i++) {
            result.servers[i] = [];
            resp['servers'][i] = resp['servers'][i] || [];
            for (let i2 = 0; i2 < resp['servers'][i].length; i2++) {
              // github.com/juju/juju/apiserver/params#HostPort
              if (resp['servers'][i][i2]) {
                result.servers[i][i2] = {};
                // github.com/juju/juju/apiserver/params#Address
                if (resp['servers'][i][i2]['Address']) {
                  result.servers[i][i2].address = {};
                  result.servers[i][i2].address.value = resp['servers'][i][i2]['Address']['value'];
                  result.servers[i][i2].address.type = resp['servers'][i][i2]['Address']['type'];
                  result.servers[i][i2].address.scope = resp['servers'][i][i2]['Address']['scope'];
                  result.servers[i][i2].address.spaceName = resp['servers'][i][i2]['Address']['space-name'];
                }
                result.servers[i][i2].port = resp['servers'][i][i2]['port'];
              }
            }
          }
          result.caCert = resp['ca-cert'];
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }
}


const wrappers = require('../wrappers.js');
if (wrappers.wrapAdmin) {
  // Decorate the facade class in order to improve user experience.
  AdminV3 = wrappers.wrapAdmin(AdminV3);
}

module.exports = AdminV3;