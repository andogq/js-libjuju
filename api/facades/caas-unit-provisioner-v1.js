/**
  Juju CAASUnitProvisioner version 1.
  This API facade is available on model connections.

  NOTE: this file has been generated by the generate command in js-libjuju
  on Fri 2018/11/09 14:32:38 UTC. Do not manually edit this file.
*/

'use strict';

const {createAsyncHandler} = require('../transform.js');

/**
  There is no documentation for this facade.
*/
class CAASUnitProvisionerV1 {

  constructor(transport, info) {
    this._transport = transport;
    this._info = info;
    this.version = 1;
  }

  /**
    ApplicationsConfig returns the config for the specified applications.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          entities: []{
            tag: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            config: map[string]anything,
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  applicationsConfig(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#Entities
      if (args) {
        params = {};
        params['entities'] = [];
        args.entities = args.entities || [];
        for (let i = 0; i < args.entities.length; i++) {
          // github.com/juju/juju/apiserver/params#Entity
          if (args.entities[i]) {
            params['entities'][i] = {};
            params['entities'][i]['tag'] = args.entities[i].tag;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'CAASUnitProvisioner',
        request: 'ApplicationsConfig',
        version: 1,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ApplicationGetConfigResults
        if (resp) {
          result = {};
          result.results = [];
          resp['Results'] = resp['Results'] || [];
          for (let i = 0; i < resp['Results'].length; i++) {
            // github.com/juju/juju/apiserver/params#ConfigResult
            if (resp['Results'][i]) {
              result.results[i] = {};
              result.results[i].config = {};
              resp['Results'][i]['config'] = resp['Results'][i]['config'] || {};
              for (let k in resp['Results'][i]['config']) {
                result.results[i].config[k] = resp['Results'][i]['config'][k];
              }
              // github.com/juju/juju/apiserver/params#Error
              if (resp['Results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['Results'][i]['error']['message'];
                result.results[i].error.code = resp['Results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['Results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['Results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['Results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    ApplicationsScale returns the scaling info for specified applications in
    this model.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          entities: []{
            tag: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            },
            result: int
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  applicationsScale(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#Entities
      if (args) {
        params = {};
        params['entities'] = [];
        args.entities = args.entities || [];
        for (let i = 0; i < args.entities.length; i++) {
          // github.com/juju/juju/apiserver/params#Entity
          if (args.entities[i]) {
            params['entities'][i] = {};
            params['entities'][i]['tag'] = args.entities[i].tag;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'CAASUnitProvisioner',
        request: 'ApplicationsScale',
        version: 1,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#IntResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#IntResult
            if (resp['results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
              result.results[i].result = resp['results'][i]['result'];
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    Life returns the life status of every supplied entity, where available.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          entities: []{
            tag: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            life: string,
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  life(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#Entities
      if (args) {
        params = {};
        params['entities'] = [];
        args.entities = args.entities || [];
        for (let i = 0; i < args.entities.length; i++) {
          // github.com/juju/juju/apiserver/params#Entity
          if (args.entities[i]) {
            params['entities'][i] = {};
            params['entities'][i]['tag'] = args.entities[i].tag;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'CAASUnitProvisioner',
        request: 'Life',
        version: 1,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#LifeResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#LifeResult
            if (resp['results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/apiserver/params#Life
              result.results[i].life = resp['results'][i]['life'];
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    ProvisioningInfo returns the provisioning info for specified applications
    in this model.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          entities: []{
            tag: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            },
            result: {
              podSpec: string,
              constraints: {
                arch: string,
                container: string,
                cores: int,
                cpuPower: int,
                mem: int,
                rootDisk: int,
                tags: []string,
                instanceType: string,
                spaces: []string,
                virtType: string
              },
              placement: string,
              tags: map[string]string,
              filesystems: []{
                storagename: string,
                size: int,
                provider: string,
                attributes: map[string]anything,
                tags: map[string]string,
                attachment: {
                  provider: string,
                  mountPoint: string,
                  readOnly: bool
                }
              },
              volumes: []{
                storagename: string,
                size: int,
                provider: string,
                attributes: map[string]anything,
                tags: map[string]string,
                attachment: {
                  provider: string,
                  readOnly: bool
                }
              },
              devices: []{
                type: string,
                count: int,
                attributes: map[string]string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  provisioningInfo(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#Entities
      if (args) {
        params = {};
        params['entities'] = [];
        args.entities = args.entities || [];
        for (let i = 0; i < args.entities.length; i++) {
          // github.com/juju/juju/apiserver/params#Entity
          if (args.entities[i]) {
            params['entities'][i] = {};
            params['entities'][i]['tag'] = args.entities[i].tag;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'CAASUnitProvisioner',
        request: 'ProvisioningInfo',
        version: 1,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#KubernetesProvisioningInfoResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#KubernetesProvisioningInfoResult
            if (resp['results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
              // github.com/juju/juju/apiserver/params#KubernetesProvisioningInfo
              if (resp['results'][i]['result']) {
                result.results[i].result = {};
                result.results[i].result.podSpec = resp['results'][i]['result']['pod-spec'];
                // github.com/juju/juju/constraints#Value
                if (resp['results'][i]['result']['constraints']) {
                  result.results[i].result.constraints = {};
                  result.results[i].result.constraints.arch = resp['results'][i]['result']['constraints']['arch'];
                  // github.com/juju/juju/instance#ContainerType
                  result.results[i].result.constraints.container = resp['results'][i]['result']['constraints']['container'];
                  result.results[i].result.constraints.cores = resp['results'][i]['result']['constraints']['cores'];
                  result.results[i].result.constraints.cpuPower = resp['results'][i]['result']['constraints']['cpu-power'];
                  result.results[i].result.constraints.mem = resp['results'][i]['result']['constraints']['mem'];
                  result.results[i].result.constraints.rootDisk = resp['results'][i]['result']['constraints']['root-disk'];
                  result.results[i].result.constraints.tags = [];
                  resp['results'][i]['result']['constraints']['tags'] = resp['results'][i]['result']['constraints']['tags'] || [];
                  for (let i2 = 0; i2 < resp['results'][i]['result']['constraints']['tags'].length; i2++) {
                    result.results[i].result.constraints.tags[i2] = resp['results'][i]['result']['constraints']['tags'][i2];
                  }
                  result.results[i].result.constraints.instanceType = resp['results'][i]['result']['constraints']['instance-type'];
                  result.results[i].result.constraints.spaces = [];
                  resp['results'][i]['result']['constraints']['spaces'] = resp['results'][i]['result']['constraints']['spaces'] || [];
                  for (let i2 = 0; i2 < resp['results'][i]['result']['constraints']['spaces'].length; i2++) {
                    result.results[i].result.constraints.spaces[i2] = resp['results'][i]['result']['constraints']['spaces'][i2];
                  }
                  result.results[i].result.constraints.virtType = resp['results'][i]['result']['constraints']['virt-type'];
                }
                result.results[i].result.placement = resp['results'][i]['result']['placement'];
                result.results[i].result.tags = {};
                resp['results'][i]['result']['tags'] = resp['results'][i]['result']['tags'] || {};
                for (let k in resp['results'][i]['result']['tags']) {
                  result.results[i].result.tags[k] = resp['results'][i]['result']['tags'][k];
                }
                result.results[i].result.filesystems = [];
                resp['results'][i]['result']['filesystems'] = resp['results'][i]['result']['filesystems'] || [];
                for (let i2 = 0; i2 < resp['results'][i]['result']['filesystems'].length; i2++) {
                  // github.com/juju/juju/apiserver/params#KubernetesFilesystemParams
                  if (resp['results'][i]['result']['filesystems'][i2]) {
                    result.results[i].result.filesystems[i2] = {};
                    result.results[i].result.filesystems[i2].storagename = resp['results'][i]['result']['filesystems'][i2]['storagename'];
                    result.results[i].result.filesystems[i2].size = resp['results'][i]['result']['filesystems'][i2]['size'];
                    result.results[i].result.filesystems[i2].provider = resp['results'][i]['result']['filesystems'][i2]['provider'];
                    result.results[i].result.filesystems[i2].attributes = {};
                    resp['results'][i]['result']['filesystems'][i2]['attributes'] = resp['results'][i]['result']['filesystems'][i2]['attributes'] || {};
                    for (let k in resp['results'][i]['result']['filesystems'][i2]['attributes']) {
                      result.results[i].result.filesystems[i2].attributes[k] = resp['results'][i]['result']['filesystems'][i2]['attributes'][k];
                    }
                    result.results[i].result.filesystems[i2].tags = {};
                    resp['results'][i]['result']['filesystems'][i2]['tags'] = resp['results'][i]['result']['filesystems'][i2]['tags'] || {};
                    for (let k in resp['results'][i]['result']['filesystems'][i2]['tags']) {
                      result.results[i].result.filesystems[i2].tags[k] = resp['results'][i]['result']['filesystems'][i2]['tags'][k];
                    }
                    // github.com/juju/juju/apiserver/params#KubernetesFilesystemAttachmentParams
                    if (resp['results'][i]['result']['filesystems'][i2]['attachment']) {
                      result.results[i].result.filesystems[i2].attachment = {};
                      result.results[i].result.filesystems[i2].attachment.provider = resp['results'][i]['result']['filesystems'][i2]['attachment']['provider'];
                      result.results[i].result.filesystems[i2].attachment.mountPoint = resp['results'][i]['result']['filesystems'][i2]['attachment']['mount-point'];
                      result.results[i].result.filesystems[i2].attachment.readOnly = resp['results'][i]['result']['filesystems'][i2]['attachment']['read-only'];
                    }
                  }
                }
                result.results[i].result.volumes = [];
                resp['results'][i]['result']['volumes'] = resp['results'][i]['result']['volumes'] || [];
                for (let i2 = 0; i2 < resp['results'][i]['result']['volumes'].length; i2++) {
                  // github.com/juju/juju/apiserver/params#KubernetesVolumeParams
                  if (resp['results'][i]['result']['volumes'][i2]) {
                    result.results[i].result.volumes[i2] = {};
                    result.results[i].result.volumes[i2].storagename = resp['results'][i]['result']['volumes'][i2]['storagename'];
                    result.results[i].result.volumes[i2].size = resp['results'][i]['result']['volumes'][i2]['size'];
                    result.results[i].result.volumes[i2].provider = resp['results'][i]['result']['volumes'][i2]['provider'];
                    result.results[i].result.volumes[i2].attributes = {};
                    resp['results'][i]['result']['volumes'][i2]['attributes'] = resp['results'][i]['result']['volumes'][i2]['attributes'] || {};
                    for (let k in resp['results'][i]['result']['volumes'][i2]['attributes']) {
                      result.results[i].result.volumes[i2].attributes[k] = resp['results'][i]['result']['volumes'][i2]['attributes'][k];
                    }
                    result.results[i].result.volumes[i2].tags = {};
                    resp['results'][i]['result']['volumes'][i2]['tags'] = resp['results'][i]['result']['volumes'][i2]['tags'] || {};
                    for (let k in resp['results'][i]['result']['volumes'][i2]['tags']) {
                      result.results[i].result.volumes[i2].tags[k] = resp['results'][i]['result']['volumes'][i2]['tags'][k];
                    }
                    // github.com/juju/juju/apiserver/params#KubernetesVolumeAttachmentParams
                    if (resp['results'][i]['result']['volumes'][i2]['attachment']) {
                      result.results[i].result.volumes[i2].attachment = {};
                      result.results[i].result.volumes[i2].attachment.provider = resp['results'][i]['result']['volumes'][i2]['attachment']['provider'];
                      result.results[i].result.volumes[i2].attachment.readOnly = resp['results'][i]['result']['volumes'][i2]['attachment']['read-only'];
                    }
                  }
                }
                result.results[i].result.devices = [];
                resp['results'][i]['result']['devices'] = resp['results'][i]['result']['devices'] || [];
                for (let i2 = 0; i2 < resp['results'][i]['result']['devices'].length; i2++) {
                  // github.com/juju/juju/apiserver/params#KubernetesDeviceParams
                  if (resp['results'][i]['result']['devices'][i2]) {
                    result.results[i].result.devices[i2] = {};
                    // github.com/juju/juju/apiserver/params#DeviceType
                    result.results[i].result.devices[i2].type = resp['results'][i]['result']['devices'][i2]['Type'];
                    result.results[i].result.devices[i2].count = resp['results'][i]['result']['devices'][i2]['Count'];
                    result.results[i].result.devices[i2].attributes = {};
                    resp['results'][i]['result']['devices'][i2]['Attributes'] = resp['results'][i]['result']['devices'][i2]['Attributes'] || {};
                    for (let k in resp['results'][i]['result']['devices'][i2]['Attributes']) {
                      result.results[i].result.devices[i2].attributes[k] = resp['results'][i]['result']['devices'][i2]['Attributes'][k];
                    }
                  }
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    SetOperatorStatus updates the operator status for each given application.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          entities: []{
            tag: string,
            status: string,
            info: string,
            data: map[string]anything
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  setOperatorStatus(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#SetStatus
      if (args) {
        params = {};
        params['entities'] = [];
        args.entities = args.entities || [];
        for (let i = 0; i < args.entities.length; i++) {
          // github.com/juju/juju/apiserver/params#EntityStatusArgs
          if (args.entities[i]) {
            params['entities'][i] = {};
            params['entities'][i]['tag'] = args.entities[i].tag;
            params['entities'][i]['status'] = args.entities[i].status;
            params['entities'][i]['info'] = args.entities[i].info;
            params['entities'][i]['data'] = {};
            args.entities[i].data = args.entities[i].data || {};
            for (let k in args.entities[i].data) {
              params['entities'][i]['data'][k] = args.entities[i].data[k];
            }
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'CAASUnitProvisioner',
        request: 'SetOperatorStatus',
        version: 1,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ErrorResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#ErrorResult
            if (resp['results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    UpdateApplicationsService updates the Juju data model to reflect the given
    service details of the specified application.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          args: []{
            applicationTag: string,
            providerId: string,
            addresses: []{
              value: string,
              type: string,
              scope: string,
              spaceName: string
            }
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  updateApplicationsService(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#UpdateApplicationServiceArgs
      if (args) {
        params = {};
        params['args'] = [];
        args.args = args.args || [];
        for (let i = 0; i < args.args.length; i++) {
          // github.com/juju/juju/apiserver/params#UpdateApplicationServiceArg
          if (args.args[i]) {
            params['args'][i] = {};
            params['args'][i]['application-tag'] = args.args[i].applicationTag;
            params['args'][i]['provider-id'] = args.args[i].providerId;
            params['args'][i]['addresses'] = [];
            args.args[i].addresses = args.args[i].addresses || [];
            for (let i2 = 0; i2 < args.args[i].addresses.length; i2++) {
              // github.com/juju/juju/apiserver/params#Address
              if (args.args[i].addresses[i2]) {
                params['args'][i]['addresses'][i2] = {};
                params['args'][i]['addresses'][i2]['value'] = args.args[i].addresses[i2].value;
                params['args'][i]['addresses'][i2]['type'] = args.args[i].addresses[i2].type;
                params['args'][i]['addresses'][i2]['scope'] = args.args[i].addresses[i2].scope;
                params['args'][i]['addresses'][i2]['space-name'] = args.args[i].addresses[i2].spaceName;
              }
            }
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'CAASUnitProvisioner',
        request: 'UpdateApplicationsService',
        version: 1,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ErrorResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#ErrorResult
            if (resp['results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    UpdateApplicationsUnits updates the Juju data model to reflect the given
    units of the specified application.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          args: []{
            applicationTag: string,
            units: []{
              providerId: string,
              unitTag: string,
              address: string,
              ports: []string,
              filesystemInfo: []{
                storagename: string,
                pool: string,
                size: int,
                mountPoint: string,
                readOnly: bool,
                filesystemId: string,
                status: string,
                info: string,
                data: map[string]anything,
                volume: {
                  volumeId: string,
                  pool: string,
                  size: int,
                  persistent: bool,
                  status: string,
                  info: string,
                  data: map[string]anything
                }
              },
              status: string,
              info: string,
              data: map[string]anything
            }
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  updateApplicationsUnits(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#UpdateApplicationUnitArgs
      if (args) {
        params = {};
        params['args'] = [];
        args.args = args.args || [];
        for (let i = 0; i < args.args.length; i++) {
          // github.com/juju/juju/apiserver/params#UpdateApplicationUnits
          if (args.args[i]) {
            params['args'][i] = {};
            params['args'][i]['application-tag'] = args.args[i].applicationTag;
            params['args'][i]['units'] = [];
            args.args[i].units = args.args[i].units || [];
            for (let i2 = 0; i2 < args.args[i].units.length; i2++) {
              // github.com/juju/juju/apiserver/params#ApplicationUnitParams
              if (args.args[i].units[i2]) {
                params['args'][i]['units'][i2] = {};
                params['args'][i]['units'][i2]['provider-id'] = args.args[i].units[i2].providerId;
                params['args'][i]['units'][i2]['unit-tag'] = args.args[i].units[i2].unitTag;
                params['args'][i]['units'][i2]['address'] = args.args[i].units[i2].address;
                params['args'][i]['units'][i2]['ports'] = [];
                args.args[i].units[i2].ports = args.args[i].units[i2].ports || [];
                for (let i3 = 0; i3 < args.args[i].units[i2].ports.length; i3++) {
                  params['args'][i]['units'][i2]['ports'][i3] = args.args[i].units[i2].ports[i3];
                }
                params['args'][i]['units'][i2]['filesystem-info'] = [];
                args.args[i].units[i2].filesystemInfo = args.args[i].units[i2].filesystemInfo || [];
                for (let i3 = 0; i3 < args.args[i].units[i2].filesystemInfo.length; i3++) {
                  // github.com/juju/juju/apiserver/params#KubernetesFilesystemInfo
                  if (args.args[i].units[i2].filesystemInfo[i3]) {
                    params['args'][i]['units'][i2]['filesystem-info'][i3] = {};
                    params['args'][i]['units'][i2]['filesystem-info'][i3]['storagename'] = args.args[i].units[i2].filesystemInfo[i3].storagename;
                    params['args'][i]['units'][i2]['filesystem-info'][i3]['pool'] = args.args[i].units[i2].filesystemInfo[i3].pool;
                    params['args'][i]['units'][i2]['filesystem-info'][i3]['size'] = args.args[i].units[i2].filesystemInfo[i3].size;
                    params['args'][i]['units'][i2]['filesystem-info'][i3]['mount-point'] = args.args[i].units[i2].filesystemInfo[i3].mountPoint;
                    params['args'][i]['units'][i2]['filesystem-info'][i3]['read-only'] = args.args[i].units[i2].filesystemInfo[i3].readOnly;
                    params['args'][i]['units'][i2]['filesystem-info'][i3]['filesystem-id'] = args.args[i].units[i2].filesystemInfo[i3].filesystemId;
                    params['args'][i]['units'][i2]['filesystem-info'][i3]['status'] = args.args[i].units[i2].filesystemInfo[i3].status;
                    params['args'][i]['units'][i2]['filesystem-info'][i3]['info'] = args.args[i].units[i2].filesystemInfo[i3].info;
                    params['args'][i]['units'][i2]['filesystem-info'][i3]['data'] = {};
                    args.args[i].units[i2].filesystemInfo[i3].data = args.args[i].units[i2].filesystemInfo[i3].data || {};
                    for (let k in args.args[i].units[i2].filesystemInfo[i3].data) {
                      params['args'][i]['units'][i2]['filesystem-info'][i3]['data'][k] = args.args[i].units[i2].filesystemInfo[i3].data[k];
                    }
                    // github.com/juju/juju/apiserver/params#KubernetesVolumeInfo
                    if (args.args[i].units[i2].filesystemInfo[i3].volume) {
                      params['args'][i]['units'][i2]['filesystem-info'][i3]['volume'] = {};
                      params['args'][i]['units'][i2]['filesystem-info'][i3]['volume']['volume-id'] = args.args[i].units[i2].filesystemInfo[i3].volume.volumeId;
                      params['args'][i]['units'][i2]['filesystem-info'][i3]['volume']['pool'] = args.args[i].units[i2].filesystemInfo[i3].volume.pool;
                      params['args'][i]['units'][i2]['filesystem-info'][i3]['volume']['size'] = args.args[i].units[i2].filesystemInfo[i3].volume.size;
                      params['args'][i]['units'][i2]['filesystem-info'][i3]['volume']['persistent'] = args.args[i].units[i2].filesystemInfo[i3].volume.persistent;
                      params['args'][i]['units'][i2]['filesystem-info'][i3]['volume']['status'] = args.args[i].units[i2].filesystemInfo[i3].volume.status;
                      params['args'][i]['units'][i2]['filesystem-info'][i3]['volume']['info'] = args.args[i].units[i2].filesystemInfo[i3].volume.info;
                      params['args'][i]['units'][i2]['filesystem-info'][i3]['volume']['data'] = {};
                      args.args[i].units[i2].filesystemInfo[i3].volume.data = args.args[i].units[i2].filesystemInfo[i3].volume.data || {};
                      for (let k in args.args[i].units[i2].filesystemInfo[i3].volume.data) {
                        params['args'][i]['units'][i2]['filesystem-info'][i3]['volume']['data'][k] = args.args[i].units[i2].filesystemInfo[i3].volume.data[k];
                      }
                    }
                  }
                }
                params['args'][i]['units'][i2]['status'] = args.args[i].units[i2].status;
                params['args'][i]['units'][i2]['info'] = args.args[i].units[i2].info;
                params['args'][i]['units'][i2]['data'] = {};
                args.args[i].units[i2].data = args.args[i].units[i2].data || {};
                for (let k in args.args[i].units[i2].data) {
                  params['args'][i]['units'][i2]['data'][k] = args.args[i].units[i2].data[k];
                }
              }
            }
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'CAASUnitProvisioner',
        request: 'UpdateApplicationsUnits',
        version: 1,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ErrorResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#ErrorResult
            if (resp['results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    WatchApplications starts a StringsWatcher to watch CAAS applications
    deployed to this model.

    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          watcherId: string,
          changes: []string,
          error: {
            message: string,
            code: string,
            info: {
              macaroon: anything,
              macaroonPath: string
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  watchApplications(callback) {
    return new Promise((resolve, reject) => {
      const params = {};
      // Prepare the request to the Juju API.
      const req = {
        type: 'CAASUnitProvisioner',
        request: 'WatchApplications',
        version: 1,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#StringsWatchResult
        if (resp) {
          result = {};
          result.watcherId = resp['watcher-id'];
          result.changes = [];
          resp['changes'] = resp['changes'] || [];
          for (let i = 0; i < resp['changes'].length; i++) {
            result.changes[i] = resp['changes'][i];
          }
          // github.com/juju/juju/apiserver/params#Error
          if (resp['error']) {
            result.error = {};
            result.error.message = resp['error']['message'];
            result.error.code = resp['error']['code'];
            // github.com/juju/juju/apiserver/params#ErrorInfo
            if (resp['error']['info']) {
              result.error.info = {};
              // gopkg.in/macaroon.v2-unstable#Macaroon
              result.error.info.macaroon = resp['error']['info']['macaroon'];
              result.error.info.macaroonPath = resp['error']['info']['macaroon-path'];
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    WatchApplicationsScale starts a NotifyWatcher to watch changes to the
    applications' scale.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          entities: []{
            tag: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            notifywatcherid: string,
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  watchApplicationsScale(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#Entities
      if (args) {
        params = {};
        params['entities'] = [];
        args.entities = args.entities || [];
        for (let i = 0; i < args.entities.length; i++) {
          // github.com/juju/juju/apiserver/params#Entity
          if (args.entities[i]) {
            params['entities'][i] = {};
            params['entities'][i]['tag'] = args.entities[i].tag;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'CAASUnitProvisioner',
        request: 'WatchApplicationsScale',
        version: 1,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#NotifyWatchResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#NotifyWatchResult
            if (resp['results'][i]) {
              result.results[i] = {};
              result.results[i].notifywatcherid = resp['results'][i]['NotifyWatcherId'];
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    WatchPodSpec starts a NotifyWatcher to watch changes to the pod spec for
    specified units in this model.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          entities: []{
            tag: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            notifywatcherid: string,
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  watchPodSpec(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#Entities
      if (args) {
        params = {};
        params['entities'] = [];
        args.entities = args.entities || [];
        for (let i = 0; i < args.entities.length; i++) {
          // github.com/juju/juju/apiserver/params#Entity
          if (args.entities[i]) {
            params['entities'][i] = {};
            params['entities'][i]['tag'] = args.entities[i].tag;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'CAASUnitProvisioner',
        request: 'WatchPodSpec',
        version: 1,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#NotifyWatchResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#NotifyWatchResult
            if (resp['results'][i]) {
              result.results[i] = {};
              result.results[i].notifywatcherid = resp['results'][i]['NotifyWatcherId'];
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }
}


const wrappers = require('../wrappers.js');
if (wrappers.wrapCAASUnitProvisioner) {
  // Decorate the facade class in order to improve user experience.
  CAASUnitProvisionerV1 = wrappers.wrapCAASUnitProvisioner(CAASUnitProvisionerV1);
}

module.exports = CAASUnitProvisionerV1;