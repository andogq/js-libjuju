/**
  Juju MachineManager version 3.
  This API facade is available on model connections.

  NOTE: this file has been generated by the generate command in js-libjuju
  on Fri 2018/11/16 13:11:58 UTC. Do not manually edit this file.
*/

'use strict';

const {autoBind, createAsyncHandler} = require('../transform.js');

/**
  MachineManagerAPI provides access to the MachineManager API facade.
*/
class MachineManagerV3 {

  constructor(transport, info) {
    this._transport = transport;
    this._info = info;
    this.version = 3;

    // Automatically bind all methods to instances.
    autoBind(this);
  }

  /**
    AddMachines adds new machines with the supplied parameters.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          params: []{
            series: string,
            constraints: {
              arch: string,
              container: string,
              cores: int,
              cpuPower: int,
              mem: int,
              rootDisk: int,
              tags: []string,
              instanceType: string,
              spaces: []string,
              virtType: string
            },
            jobs: []string,
            disks: []{
              pool: string,
              size: int,
              count: int
            },
            placement: {
              scope: string,
              directive: string
            },
            parentId: string,
            containerType: string,
            instanceId: string,
            nonce: string,
            hardwareCharacteristics: {
              arch: string,
              mem: int,
              rootDisk: int,
              cpuCores: int,
              cpuPower: int,
              tags: []string,
              availabilityZone: string
            },
            addresses: []{
              value: string,
              type: string,
              scope: string,
              spaceName: string
            }
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          machines: []{
            machine: string,
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  addMachines(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#AddMachines
      if (args) {
        params = {};
        params['params'] = [];
        args.params = args.params || [];
        for (let i = 0; i < args.params.length; i++) {
          // github.com/juju/juju/apiserver/params#AddMachineParams
          if (args.params[i]) {
            params['params'][i] = {};
            params['params'][i]['series'] = args.params[i].series;
            // github.com/juju/juju/constraints#Value
            if (args.params[i].constraints) {
              params['params'][i]['constraints'] = {};
              params['params'][i]['constraints']['arch'] = args.params[i].constraints.arch;
              // github.com/juju/juju/instance#ContainerType
              params['params'][i]['constraints']['container'] = args.params[i].constraints.container;
              params['params'][i]['constraints']['cores'] = args.params[i].constraints.cores;
              params['params'][i]['constraints']['cpu-power'] = args.params[i].constraints.cpuPower;
              params['params'][i]['constraints']['mem'] = args.params[i].constraints.mem;
              params['params'][i]['constraints']['root-disk'] = args.params[i].constraints.rootDisk;
              params['params'][i]['constraints']['tags'] = [];
              args.params[i].constraints.tags = args.params[i].constraints.tags || [];
              for (let i2 = 0; i2 < args.params[i].constraints.tags.length; i2++) {
                params['params'][i]['constraints']['tags'][i2] = args.params[i].constraints.tags[i2];
              }
              params['params'][i]['constraints']['instance-type'] = args.params[i].constraints.instanceType;
              params['params'][i]['constraints']['spaces'] = [];
              args.params[i].constraints.spaces = args.params[i].constraints.spaces || [];
              for (let i2 = 0; i2 < args.params[i].constraints.spaces.length; i2++) {
                params['params'][i]['constraints']['spaces'][i2] = args.params[i].constraints.spaces[i2];
              }
              params['params'][i]['constraints']['virt-type'] = args.params[i].constraints.virtType;
            }
            params['params'][i]['jobs'] = [];
            args.params[i].jobs = args.params[i].jobs || [];
            for (let i2 = 0; i2 < args.params[i].jobs.length; i2++) {
              // github.com/juju/juju/state/multiwatcher#MachineJob
              params['params'][i]['jobs'][i2] = args.params[i].jobs[i2];
            }
            params['params'][i]['disks'] = [];
            args.params[i].disks = args.params[i].disks || [];
            for (let i2 = 0; i2 < args.params[i].disks.length; i2++) {
              // github.com/juju/juju/storage#Constraints
              if (args.params[i].disks[i2]) {
                params['params'][i]['disks'][i2] = {};
                params['params'][i]['disks'][i2]['Pool'] = args.params[i].disks[i2].pool;
                params['params'][i]['disks'][i2]['Size'] = args.params[i].disks[i2].size;
                params['params'][i]['disks'][i2]['Count'] = args.params[i].disks[i2].count;
              }
            }
            // github.com/juju/juju/instance#Placement
            if (args.params[i].placement) {
              params['params'][i]['placement'] = {};
              params['params'][i]['placement']['scope'] = args.params[i].placement.scope;
              params['params'][i]['placement']['directive'] = args.params[i].placement.directive;
            }
            params['params'][i]['parent-id'] = args.params[i].parentId;
            // github.com/juju/juju/instance#ContainerType
            params['params'][i]['container-type'] = args.params[i].containerType;
            // github.com/juju/juju/instance#Id
            params['params'][i]['instance-id'] = args.params[i].instanceId;
            params['params'][i]['nonce'] = args.params[i].nonce;
            // github.com/juju/juju/instance#HardwareCharacteristics
            if (args.params[i].hardwareCharacteristics) {
              params['params'][i]['hardware-characteristics'] = {};
              params['params'][i]['hardware-characteristics']['arch'] = args.params[i].hardwareCharacteristics.arch;
              params['params'][i]['hardware-characteristics']['mem'] = args.params[i].hardwareCharacteristics.mem;
              params['params'][i]['hardware-characteristics']['root-disk'] = args.params[i].hardwareCharacteristics.rootDisk;
              params['params'][i]['hardware-characteristics']['cpu-cores'] = args.params[i].hardwareCharacteristics.cpuCores;
              params['params'][i]['hardware-characteristics']['cpu-power'] = args.params[i].hardwareCharacteristics.cpuPower;
              params['params'][i]['hardware-characteristics']['tags'] = [];
              args.params[i].hardwareCharacteristics.tags = args.params[i].hardwareCharacteristics.tags || [];
              for (let i2 = 0; i2 < args.params[i].hardwareCharacteristics.tags.length; i2++) {
                params['params'][i]['hardware-characteristics']['tags'][i2] = args.params[i].hardwareCharacteristics.tags[i2];
              }
              params['params'][i]['hardware-characteristics']['availability-zone'] = args.params[i].hardwareCharacteristics.availabilityZone;
            }
            params['params'][i]['addresses'] = [];
            args.params[i].addresses = args.params[i].addresses || [];
            for (let i2 = 0; i2 < args.params[i].addresses.length; i2++) {
              // github.com/juju/juju/apiserver/params#Address
              if (args.params[i].addresses[i2]) {
                params['params'][i]['addresses'][i2] = {};
                params['params'][i]['addresses'][i2]['value'] = args.params[i].addresses[i2].value;
                params['params'][i]['addresses'][i2]['type'] = args.params[i].addresses[i2].type;
                params['params'][i]['addresses'][i2]['scope'] = args.params[i].addresses[i2].scope;
                params['params'][i]['addresses'][i2]['space-name'] = args.params[i].addresses[i2].spaceName;
              }
            }
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'MachineManager',
        request: 'AddMachines',
        version: 3,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#AddMachinesResults
        if (resp) {
          result = {};
          result.machines = [];
          resp['machines'] = resp['machines'] || [];
          for (let i = 0; i < resp['machines'].length; i++) {
            // github.com/juju/juju/apiserver/params#AddMachinesResult
            if (resp['machines'][i]) {
              result.machines[i] = {};
              result.machines[i].machine = resp['machines'][i]['machine'];
              // github.com/juju/juju/apiserver/params#Error
              if (resp['machines'][i]['error']) {
                result.machines[i].error = {};
                result.machines[i].error.message = resp['machines'][i]['error']['message'];
                result.machines[i].error.code = resp['machines'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['machines'][i]['error']['info']) {
                  result.machines[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.machines[i].error.info.macaroon = resp['machines'][i]['error']['info']['macaroon'];
                  result.machines[i].error.info.macaroonPath = resp['machines'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    DestroyMachine removes a set of machines from the model.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          entities: []{
            tag: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            },
            info: {
              detachedStorage: []{
                tag: string
              },
              destroyedStorage: []{
                tag: string
              },
              destroyedUnits: []{
                tag: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  destroyMachine(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#Entities
      if (args) {
        params = {};
        params['entities'] = [];
        args.entities = args.entities || [];
        for (let i = 0; i < args.entities.length; i++) {
          // github.com/juju/juju/apiserver/params#Entity
          if (args.entities[i]) {
            params['entities'][i] = {};
            params['entities'][i]['tag'] = args.entities[i].tag;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'MachineManager',
        request: 'DestroyMachine',
        version: 3,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#DestroyMachineResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#DestroyMachineResult
            if (resp['results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
              // github.com/juju/juju/apiserver/params#DestroyMachineInfo
              if (resp['results'][i]['info']) {
                result.results[i].info = {};
                result.results[i].info.detachedStorage = [];
                resp['results'][i]['info']['detached-storage'] = resp['results'][i]['info']['detached-storage'] || [];
                for (let i2 = 0; i2 < resp['results'][i]['info']['detached-storage'].length; i2++) {
                  // github.com/juju/juju/apiserver/params#Entity
                  if (resp['results'][i]['info']['detached-storage'][i2]) {
                    result.results[i].info.detachedStorage[i2] = {};
                    result.results[i].info.detachedStorage[i2].tag = resp['results'][i]['info']['detached-storage'][i2]['tag'];
                  }
                }
                result.results[i].info.destroyedStorage = [];
                resp['results'][i]['info']['destroyed-storage'] = resp['results'][i]['info']['destroyed-storage'] || [];
                for (let i2 = 0; i2 < resp['results'][i]['info']['destroyed-storage'].length; i2++) {
                  // github.com/juju/juju/apiserver/params#Entity
                  if (resp['results'][i]['info']['destroyed-storage'][i2]) {
                    result.results[i].info.destroyedStorage[i2] = {};
                    result.results[i].info.destroyedStorage[i2].tag = resp['results'][i]['info']['destroyed-storage'][i2]['tag'];
                  }
                }
                result.results[i].info.destroyedUnits = [];
                resp['results'][i]['info']['destroyed-units'] = resp['results'][i]['info']['destroyed-units'] || [];
                for (let i2 = 0; i2 < resp['results'][i]['info']['destroyed-units'].length; i2++) {
                  // github.com/juju/juju/apiserver/params#Entity
                  if (resp['results'][i]['info']['destroyed-units'][i2]) {
                    result.results[i].info.destroyedUnits[i2] = {};
                    result.results[i].info.destroyedUnits[i2].tag = resp['results'][i]['info']['destroyed-units'][i2]['tag'];
                  }
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    DestroyMachineWithParams removes a set of machines from the model.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          machineTags: []string,
          force: bool,
          keep: bool
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            },
            info: {
              detachedStorage: []{
                tag: string
              },
              destroyedStorage: []{
                tag: string
              },
              destroyedUnits: []{
                tag: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  destroyMachineWithParams(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#DestroyMachinesParams
      if (args) {
        params = {};
        params['machine-tags'] = [];
        args.machineTags = args.machineTags || [];
        for (let i = 0; i < args.machineTags.length; i++) {
          params['machine-tags'][i] = args.machineTags[i];
        }
        params['force'] = args.force;
        params['keep'] = args.keep;
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'MachineManager',
        request: 'DestroyMachineWithParams',
        version: 3,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#DestroyMachineResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#DestroyMachineResult
            if (resp['results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
              // github.com/juju/juju/apiserver/params#DestroyMachineInfo
              if (resp['results'][i]['info']) {
                result.results[i].info = {};
                result.results[i].info.detachedStorage = [];
                resp['results'][i]['info']['detached-storage'] = resp['results'][i]['info']['detached-storage'] || [];
                for (let i2 = 0; i2 < resp['results'][i]['info']['detached-storage'].length; i2++) {
                  // github.com/juju/juju/apiserver/params#Entity
                  if (resp['results'][i]['info']['detached-storage'][i2]) {
                    result.results[i].info.detachedStorage[i2] = {};
                    result.results[i].info.detachedStorage[i2].tag = resp['results'][i]['info']['detached-storage'][i2]['tag'];
                  }
                }
                result.results[i].info.destroyedStorage = [];
                resp['results'][i]['info']['destroyed-storage'] = resp['results'][i]['info']['destroyed-storage'] || [];
                for (let i2 = 0; i2 < resp['results'][i]['info']['destroyed-storage'].length; i2++) {
                  // github.com/juju/juju/apiserver/params#Entity
                  if (resp['results'][i]['info']['destroyed-storage'][i2]) {
                    result.results[i].info.destroyedStorage[i2] = {};
                    result.results[i].info.destroyedStorage[i2].tag = resp['results'][i]['info']['destroyed-storage'][i2]['tag'];
                  }
                }
                result.results[i].info.destroyedUnits = [];
                resp['results'][i]['info']['destroyed-units'] = resp['results'][i]['info']['destroyed-units'] || [];
                for (let i2 = 0; i2 < resp['results'][i]['info']['destroyed-units'].length; i2++) {
                  // github.com/juju/juju/apiserver/params#Entity
                  if (resp['results'][i]['info']['destroyed-units'][i2]) {
                    result.results[i].info.destroyedUnits[i2] = {};
                    result.results[i].info.destroyedUnits[i2].tag = resp['results'][i]['info']['destroyed-units'][i2]['tag'];
                  }
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    ForceDestroyMachine forcibly removes a set of machines from the model.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          entities: []{
            tag: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            },
            info: {
              detachedStorage: []{
                tag: string
              },
              destroyedStorage: []{
                tag: string
              },
              destroyedUnits: []{
                tag: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  forceDestroyMachine(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#Entities
      if (args) {
        params = {};
        params['entities'] = [];
        args.entities = args.entities || [];
        for (let i = 0; i < args.entities.length; i++) {
          // github.com/juju/juju/apiserver/params#Entity
          if (args.entities[i]) {
            params['entities'][i] = {};
            params['entities'][i]['tag'] = args.entities[i].tag;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'MachineManager',
        request: 'ForceDestroyMachine',
        version: 3,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#DestroyMachineResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#DestroyMachineResult
            if (resp['results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
              // github.com/juju/juju/apiserver/params#DestroyMachineInfo
              if (resp['results'][i]['info']) {
                result.results[i].info = {};
                result.results[i].info.detachedStorage = [];
                resp['results'][i]['info']['detached-storage'] = resp['results'][i]['info']['detached-storage'] || [];
                for (let i2 = 0; i2 < resp['results'][i]['info']['detached-storage'].length; i2++) {
                  // github.com/juju/juju/apiserver/params#Entity
                  if (resp['results'][i]['info']['detached-storage'][i2]) {
                    result.results[i].info.detachedStorage[i2] = {};
                    result.results[i].info.detachedStorage[i2].tag = resp['results'][i]['info']['detached-storage'][i2]['tag'];
                  }
                }
                result.results[i].info.destroyedStorage = [];
                resp['results'][i]['info']['destroyed-storage'] = resp['results'][i]['info']['destroyed-storage'] || [];
                for (let i2 = 0; i2 < resp['results'][i]['info']['destroyed-storage'].length; i2++) {
                  // github.com/juju/juju/apiserver/params#Entity
                  if (resp['results'][i]['info']['destroyed-storage'][i2]) {
                    result.results[i].info.destroyedStorage[i2] = {};
                    result.results[i].info.destroyedStorage[i2].tag = resp['results'][i]['info']['destroyed-storage'][i2]['tag'];
                  }
                }
                result.results[i].info.destroyedUnits = [];
                resp['results'][i]['info']['destroyed-units'] = resp['results'][i]['info']['destroyed-units'] || [];
                for (let i2 = 0; i2 < resp['results'][i]['info']['destroyed-units'].length; i2++) {
                  // github.com/juju/juju/apiserver/params#Entity
                  if (resp['results'][i]['info']['destroyed-units'][i2]) {
                    result.results[i].info.destroyedUnits[i2] = {};
                    result.results[i].info.destroyedUnits[i2].tag = resp['results'][i]['info']['destroyed-units'][i2]['tag'];
                  }
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    GetUpgradeSeriesMessages returns all new messages associated with upgrade
    series events. Messages that have already been retrieved once are not
    returned by this method.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          params: []{
            entity: {
              tag: string
            },
            watcherId: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            },
            result: []string
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  getUpgradeSeriesMessages(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#UpgradeSeriesNotificationParams
      if (args) {
        params = {};
        params['params'] = [];
        args.params = args.params || [];
        for (let i = 0; i < args.params.length; i++) {
          // github.com/juju/juju/apiserver/params#UpgradeSeriesNotificationParam
          if (args.params[i]) {
            params['params'][i] = {};
            // github.com/juju/juju/apiserver/params#Entity
            if (args.params[i].entity) {
              params['params'][i]['entity'] = {};
              params['params'][i]['entity']['tag'] = args.params[i].entity.tag;
            }
            params['params'][i]['watcher-id'] = args.params[i].watcherId;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'MachineManager',
        request: 'GetUpgradeSeriesMessages',
        version: 3,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#StringsResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#StringsResult
            if (resp['results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
              result.results[i].result = [];
              resp['results'][i]['result'] = resp['results'][i]['result'] || [];
              for (let i2 = 0; i2 < resp['results'][i]['result'].length; i2++) {
                result.results[i].result[i2] = resp['results'][i]['result'][i2];
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    InstanceTypes returns instance type information for the cloud and region in
    which the current model is deployed.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          constraints: []{
            value: {
              arch: string,
              container: string,
              cores: int,
              cpuPower: int,
              mem: int,
              rootDisk: int,
              tags: []string,
              instanceType: string,
              spaces: []string,
              virtType: string
            }
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            instanceTypes: []{
              name: string,
              arches: []string,
              cpuCores: int,
              memory: int,
              rootDisk: int,
              virtType: string,
              deprecated: bool,
              cost: int
            },
            costUnit: string,
            costCurrency: string,
            costDivisor: int,
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  instanceTypes(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#ModelInstanceTypesConstraints
      if (args) {
        params = {};
        params['constraints'] = [];
        args.constraints = args.constraints || [];
        for (let i = 0; i < args.constraints.length; i++) {
          // github.com/juju/juju/apiserver/params#ModelInstanceTypesConstraint
          if (args.constraints[i]) {
            params['constraints'][i] = {};
            // github.com/juju/juju/constraints#Value
            if (args.constraints[i].value) {
              params['constraints'][i]['value'] = {};
              params['constraints'][i]['value']['arch'] = args.constraints[i].value.arch;
              // github.com/juju/juju/instance#ContainerType
              params['constraints'][i]['value']['container'] = args.constraints[i].value.container;
              params['constraints'][i]['value']['cores'] = args.constraints[i].value.cores;
              params['constraints'][i]['value']['cpu-power'] = args.constraints[i].value.cpuPower;
              params['constraints'][i]['value']['mem'] = args.constraints[i].value.mem;
              params['constraints'][i]['value']['root-disk'] = args.constraints[i].value.rootDisk;
              params['constraints'][i]['value']['tags'] = [];
              args.constraints[i].value.tags = args.constraints[i].value.tags || [];
              for (let i2 = 0; i2 < args.constraints[i].value.tags.length; i2++) {
                params['constraints'][i]['value']['tags'][i2] = args.constraints[i].value.tags[i2];
              }
              params['constraints'][i]['value']['instance-type'] = args.constraints[i].value.instanceType;
              params['constraints'][i]['value']['spaces'] = [];
              args.constraints[i].value.spaces = args.constraints[i].value.spaces || [];
              for (let i2 = 0; i2 < args.constraints[i].value.spaces.length; i2++) {
                params['constraints'][i]['value']['spaces'][i2] = args.constraints[i].value.spaces[i2];
              }
              params['constraints'][i]['value']['virt-type'] = args.constraints[i].value.virtType;
            }
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'MachineManager',
        request: 'InstanceTypes',
        version: 3,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#InstanceTypesResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#InstanceTypesResult
            if (resp['results'][i]) {
              result.results[i] = {};
              result.results[i].instanceTypes = [];
              resp['results'][i]['instance-types'] = resp['results'][i]['instance-types'] || [];
              for (let i2 = 0; i2 < resp['results'][i]['instance-types'].length; i2++) {
                // github.com/juju/juju/apiserver/params#InstanceType
                if (resp['results'][i]['instance-types'][i2]) {
                  result.results[i].instanceTypes[i2] = {};
                  result.results[i].instanceTypes[i2].name = resp['results'][i]['instance-types'][i2]['name'];
                  result.results[i].instanceTypes[i2].arches = [];
                  resp['results'][i]['instance-types'][i2]['arches'] = resp['results'][i]['instance-types'][i2]['arches'] || [];
                  for (let i3 = 0; i3 < resp['results'][i]['instance-types'][i2]['arches'].length; i3++) {
                    result.results[i].instanceTypes[i2].arches[i3] = resp['results'][i]['instance-types'][i2]['arches'][i3];
                  }
                  result.results[i].instanceTypes[i2].cpuCores = resp['results'][i]['instance-types'][i2]['cpu-cores'];
                  result.results[i].instanceTypes[i2].memory = resp['results'][i]['instance-types'][i2]['memory'];
                  result.results[i].instanceTypes[i2].rootDisk = resp['results'][i]['instance-types'][i2]['root-disk'];
                  result.results[i].instanceTypes[i2].virtType = resp['results'][i]['instance-types'][i2]['virt-type'];
                  result.results[i].instanceTypes[i2].deprecated = resp['results'][i]['instance-types'][i2]['deprecated'];
                  result.results[i].instanceTypes[i2].cost = resp['results'][i]['instance-types'][i2]['cost'];
                }
              }
              result.results[i].costUnit = resp['results'][i]['cost-unit'];
              result.results[i].costCurrency = resp['results'][i]['cost-currency'];
              result.results[i].costDivisor = resp['results'][i]['cost-divisor'];
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    DEPRECATED: UpdateMachineSeries updates the series of the given machine(s)
    as well as all units and subordinates installed on the machine(s).

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          args: []{
            tag: {
              tag: string
            },
            force: bool,
            series: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  updateMachineSeries(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#UpdateSeriesArgs
      if (args) {
        params = {};
        params['args'] = [];
        args.args = args.args || [];
        for (let i = 0; i < args.args.length; i++) {
          // github.com/juju/juju/apiserver/params#UpdateSeriesArg
          if (args.args[i]) {
            params['args'][i] = {};
            // github.com/juju/juju/apiserver/params#Entity
            if (args.args[i].tag) {
              params['args'][i]['tag'] = {};
              params['args'][i]['tag']['tag'] = args.args[i].tag.tag;
            }
            params['args'][i]['force'] = args.args[i].force;
            params['args'][i]['series'] = args.args[i].series;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'MachineManager',
        request: 'UpdateMachineSeries',
        version: 3,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ErrorResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#ErrorResult
            if (resp['results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    UpgradeSeriesComplete marks a machine as having completed a managed series
    upgrade.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          tag: {
            tag: string
          },
          force: bool,
          series: string
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          error: {
            message: string,
            code: string,
            info: {
              macaroon: anything,
              macaroonPath: string
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  upgradeSeriesComplete(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#UpdateSeriesArg
      if (args) {
        params = {};
        // github.com/juju/juju/apiserver/params#Entity
        if (args.tag) {
          params['tag'] = {};
          params['tag']['tag'] = args.tag.tag;
        }
        params['force'] = args.force;
        params['series'] = args.series;
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'MachineManager',
        request: 'UpgradeSeriesComplete',
        version: 3,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ErrorResult
        if (resp) {
          result = {};
          // github.com/juju/juju/apiserver/params#Error
          if (resp['error']) {
            result.error = {};
            result.error.message = resp['error']['message'];
            result.error.code = resp['error']['code'];
            // github.com/juju/juju/apiserver/params#ErrorInfo
            if (resp['error']['info']) {
              result.error.info = {};
              // gopkg.in/macaroon.v2-unstable#Macaroon
              result.error.info.macaroon = resp['error']['info']['macaroon'];
              result.error.info.macaroonPath = resp['error']['info']['macaroon-path'];
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    UpgradeSeriesPrepare prepares a machine for a OS series upgrade.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          tag: {
            tag: string
          },
          force: bool,
          series: string
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          error: {
            message: string,
            code: string,
            info: {
              macaroon: anything,
              macaroonPath: string
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  upgradeSeriesPrepare(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#UpdateSeriesArg
      if (args) {
        params = {};
        // github.com/juju/juju/apiserver/params#Entity
        if (args.tag) {
          params['tag'] = {};
          params['tag']['tag'] = args.tag.tag;
        }
        params['force'] = args.force;
        params['series'] = args.series;
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'MachineManager',
        request: 'UpgradeSeriesPrepare',
        version: 3,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ErrorResult
        if (resp) {
          result = {};
          // github.com/juju/juju/apiserver/params#Error
          if (resp['error']) {
            result.error = {};
            result.error.message = resp['error']['message'];
            result.error.code = resp['error']['code'];
            // github.com/juju/juju/apiserver/params#ErrorInfo
            if (resp['error']['info']) {
              result.error.info = {};
              // gopkg.in/macaroon.v2-unstable#Macaroon
              result.error.info.macaroon = resp['error']['info']['macaroon'];
              result.error.info.macaroonPath = resp['error']['info']['macaroon-path'];
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    UpgradeSeriesValidate validates that the incoming arguments correspond to a
    valid series upgrade for the target machine. If they do, a list of the
    machine's current units is returned for use in soliciting user
    confirmation of the command.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          args: []{
            tag: {
              tag: string
            },
            force: bool,
            series: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            },
            unitNames: []string
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  upgradeSeriesValidate(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#UpdateSeriesArgs
      if (args) {
        params = {};
        params['args'] = [];
        args.args = args.args || [];
        for (let i = 0; i < args.args.length; i++) {
          // github.com/juju/juju/apiserver/params#UpdateSeriesArg
          if (args.args[i]) {
            params['args'][i] = {};
            // github.com/juju/juju/apiserver/params#Entity
            if (args.args[i].tag) {
              params['args'][i]['tag'] = {};
              params['args'][i]['tag']['tag'] = args.args[i].tag.tag;
            }
            params['args'][i]['force'] = args.args[i].force;
            params['args'][i]['series'] = args.args[i].series;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'MachineManager',
        request: 'UpgradeSeriesValidate',
        version: 3,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#UpgradeSeriesUnitsResults
        if (resp) {
          result = {};
          result.results = [];
          resp['Results'] = resp['Results'] || [];
          for (let i = 0; i < resp['Results'].length; i++) {
            // github.com/juju/juju/apiserver/params#UpgradeSeriesUnitsResult
            if (resp['Results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/apiserver/params#Error
              if (resp['Results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['Results'][i]['error']['message'];
                result.results[i].error.code = resp['Results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['Results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['Results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['Results'][i]['error']['info']['macaroon-path'];
                }
              }
              result.results[i].unitNames = [];
              resp['Results'][i]['unit-names'] = resp['Results'][i]['unit-names'] || [];
              for (let i2 = 0; i2 < resp['Results'][i]['unit-names'].length; i2++) {
                result.results[i].unitNames[i2] = resp['Results'][i]['unit-names'][i2];
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    WatchUpgradeSeriesNotifications returns a watcher that fires on upgrade
    series events.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          entities: []{
            tag: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            notifywatcherid: string,
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  watchUpgradeSeriesNotifications(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#Entities
      if (args) {
        params = {};
        params['entities'] = [];
        args.entities = args.entities || [];
        for (let i = 0; i < args.entities.length; i++) {
          // github.com/juju/juju/apiserver/params#Entity
          if (args.entities[i]) {
            params['entities'][i] = {};
            params['entities'][i]['tag'] = args.entities[i].tag;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'MachineManager',
        request: 'WatchUpgradeSeriesNotifications',
        version: 3,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#NotifyWatchResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#NotifyWatchResult
            if (resp['results'][i]) {
              result.results[i] = {};
              result.results[i].notifywatcherid = resp['results'][i]['NotifyWatcherId'];
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }
}


const wrappers = require('../wrappers.js');
if (wrappers.wrapMachineManager) {
  // Decorate the facade class in order to improve user experience.
  MachineManagerV3 = wrappers.wrapMachineManager(MachineManagerV3);
}

module.exports = MachineManagerV3;