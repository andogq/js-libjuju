/**
  Juju RemoteRelations version 1.
  This API facade is available on model connections.

  NOTE: this file has been generated by the generate command in js-libjuju
  on Tue 2018/11/27 16:23:14 UTC. Do not manually edit this file.
*/

'use strict';

const {autoBind, createAsyncHandler} = require('../transform.js');

/**
  RemoteRelationsAPI provides access to the RemoteRelations API facade.
*/
class RemoteRelationsV1 {

  constructor(transport, info) {
    this._transport = transport;
    this._info = info;
    this.version = 1;

    // Automatically bind all methods to instances.
    autoBind(this);
  }

  /**
    ConsumeRemoteRelationChanges consumes changes to settings originating from
    the remote/offering side of relations.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          changes: []{
            relationToken: string,
            applicationToken: string,
            life: string,
            forceCleanup: bool,
            suspended: bool,
            suspendedReason: string,
            changedUnits: []{
              unitId: int,
              settings: map[string]anything
            },
            departedUnits: []int,
            macaroons: []anything
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  consumeRemoteRelationChanges(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#RemoteRelationsChanges
      if (args) {
        params = {};
        params['changes'] = [];
        args.changes = args.changes || [];
        for (let i = 0; i < args.changes.length; i++) {
          // github.com/juju/juju/apiserver/params#RemoteRelationChangeEvent
          if (args.changes[i]) {
            params['changes'][i] = {};
            params['changes'][i]['relation-token'] = args.changes[i].relationToken;
            params['changes'][i]['application-token'] = args.changes[i].applicationToken;
            // github.com/juju/juju/apiserver/params#Life
            params['changes'][i]['life'] = args.changes[i].life;
            params['changes'][i]['force-cleanup'] = args.changes[i].forceCleanup;
            params['changes'][i]['suspended'] = args.changes[i].suspended;
            params['changes'][i]['suspended-reason'] = args.changes[i].suspendedReason;
            params['changes'][i]['changed-units'] = [];
            args.changes[i].changedUnits = args.changes[i].changedUnits || [];
            for (let i2 = 0; i2 < args.changes[i].changedUnits.length; i2++) {
              // github.com/juju/juju/apiserver/params#RemoteRelationUnitChange
              if (args.changes[i].changedUnits[i2]) {
                params['changes'][i]['changed-units'][i2] = {};
                params['changes'][i]['changed-units'][i2]['unit-id'] = args.changes[i].changedUnits[i2].unitId;
                params['changes'][i]['changed-units'][i2]['settings'] = {};
                args.changes[i].changedUnits[i2].settings = args.changes[i].changedUnits[i2].settings || {};
                for (let k in args.changes[i].changedUnits[i2].settings) {
                  params['changes'][i]['changed-units'][i2]['settings'][k] = args.changes[i].changedUnits[i2].settings[k];
                }
              }
            }
            params['changes'][i]['departed-units'] = [];
            args.changes[i].departedUnits = args.changes[i].departedUnits || [];
            for (let i2 = 0; i2 < args.changes[i].departedUnits.length; i2++) {
              params['changes'][i]['departed-units'][i2] = args.changes[i].departedUnits[i2];
            }
            // gopkg.in/macaroon.v2-unstable#Slice
            params['changes'][i]['macaroons'] = [];
            args.changes[i].macaroons = args.changes[i].macaroons || [];
            for (let i2 = 0; i2 < args.changes[i].macaroons.length; i2++) {
              // gopkg.in/macaroon.v2-unstable#Macaroon
              params['changes'][i]['macaroons'][i2] = args.changes[i].macaroons[i2];
            }
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'RemoteRelations',
        request: 'ConsumeRemoteRelationChanges',
        version: 1,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ErrorResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#ErrorResult
            if (resp['results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    ControllerAPIInfoForModels returns the controller api connection details
    for the specified models.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          entities: []{
            tag: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            addresses: []string,
            cacert: string,
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  controllerAPIInfoForModels(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#Entities
      if (args) {
        params = {};
        params['entities'] = [];
        args.entities = args.entities || [];
        for (let i = 0; i < args.entities.length; i++) {
          // github.com/juju/juju/apiserver/params#Entity
          if (args.entities[i]) {
            params['entities'][i] = {};
            params['entities'][i]['tag'] = args.entities[i].tag;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'RemoteRelations',
        request: 'ControllerAPIInfoForModels',
        version: 1,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ControllerAPIInfoResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#ControllerAPIInfoResult
            if (resp['results'][i]) {
              result.results[i] = {};
              result.results[i].addresses = [];
              resp['results'][i]['addresses'] = resp['results'][i]['addresses'] || [];
              for (let i2 = 0; i2 < resp['results'][i]['addresses'].length; i2++) {
                result.results[i].addresses[i2] = resp['results'][i]['addresses'][i2];
              }
              result.results[i].cacert = resp['results'][i]['cacert'];
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    ControllerConfig returns the controller's configuration.

    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          config: map[string]anything
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  controllerConfig(callback) {
    return new Promise((resolve, reject) => {
      const params = {};
      // Prepare the request to the Juju API.
      const req = {
        type: 'RemoteRelations',
        request: 'ControllerConfig',
        version: 1,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ControllerConfigResult
        if (resp) {
          result = {};
          // github.com/juju/juju/apiserver/params#ControllerConfig
          result.config = {};
          resp['config'] = resp['config'] || {};
          for (let k in resp['config']) {
            result.config[k] = resp['config'][k];
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    ExportEntities allocates unique, remote entity IDs for the given entities
    in the local model.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          entities: []{
            tag: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            token: string,
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  exportEntities(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#Entities
      if (args) {
        params = {};
        params['entities'] = [];
        args.entities = args.entities || [];
        for (let i = 0; i < args.entities.length; i++) {
          // github.com/juju/juju/apiserver/params#Entity
          if (args.entities[i]) {
            params['entities'][i] = {};
            params['entities'][i]['tag'] = args.entities[i].tag;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'RemoteRelations',
        request: 'ExportEntities',
        version: 1,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#TokenResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#TokenResult
            if (resp['results'][i]) {
              result.results[i] = {};
              result.results[i].token = resp['results'][i]['token'];
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    GetTokens returns the token associated with the entities with the given
    tags for the given models.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          args: []{
            tag: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            },
            result: string
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  getTokens(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#GetTokenArgs
      if (args) {
        params = {};
        params['Args'] = [];
        args.args = args.args || [];
        for (let i = 0; i < args.args.length; i++) {
          // github.com/juju/juju/apiserver/params#GetTokenArg
          if (args.args[i]) {
            params['Args'][i] = {};
            params['Args'][i]['tag'] = args.args[i].tag;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'RemoteRelations',
        request: 'GetTokens',
        version: 1,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#StringResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#StringResult
            if (resp['results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
              result.results[i].result = resp['results'][i]['result'];
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    ImportRemoteEntities adds entities to the remote entities collection with
    the specified opaque tokens.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          args: []{
            tag: string,
            token: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  importRemoteEntities(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#RemoteEntityTokenArgs
      if (args) {
        params = {};
        params['Args'] = [];
        args.args = args.args || [];
        for (let i = 0; i < args.args.length; i++) {
          // github.com/juju/juju/apiserver/params#RemoteEntityTokenArg
          if (args.args[i]) {
            params['Args'][i] = {};
            params['Args'][i]['tag'] = args.args[i].tag;
            params['Args'][i]['token'] = args.args[i].token;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'RemoteRelations',
        request: 'ImportRemoteEntities',
        version: 1,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ErrorResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#ErrorResult
            if (resp['results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    RelationUnitSettings returns the relation unit settings for the given
    relation units in the local model.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          relationUnits: []{
            relation: string,
            unit: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            },
            settings: map[string]string
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  relationUnitSettings(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#RelationUnits
      if (args) {
        params = {};
        params['relation-units'] = [];
        args.relationUnits = args.relationUnits || [];
        for (let i = 0; i < args.relationUnits.length; i++) {
          // github.com/juju/juju/apiserver/params#RelationUnit
          if (args.relationUnits[i]) {
            params['relation-units'][i] = {};
            params['relation-units'][i]['relation'] = args.relationUnits[i].relation;
            params['relation-units'][i]['unit'] = args.relationUnits[i].unit;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'RemoteRelations',
        request: 'RelationUnitSettings',
        version: 1,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#SettingsResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#SettingsResult
            if (resp['results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
              // github.com/juju/juju/apiserver/params#Settings
              result.results[i].settings = {};
              resp['results'][i]['settings'] = resp['results'][i]['settings'] || {};
              for (let k in resp['results'][i]['settings']) {
                result.results[i].settings[k] = resp['results'][i]['settings'][k];
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    Relations returns information about the cross-model relations with the
    specified keys in the local model.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          entities: []{
            tag: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            },
            result: {
              life: string,
              suspended: bool,
              id: int,
              key: string,
              applicationName: string,
              endpoint: {
                name: string,
                role: string,
                interface: string,
                limit: int
              },
              remoteApplicationName: string,
              remoteEndpointName: string,
              sourceModelUuid: string
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  relations(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#Entities
      if (args) {
        params = {};
        params['entities'] = [];
        args.entities = args.entities || [];
        for (let i = 0; i < args.entities.length; i++) {
          // github.com/juju/juju/apiserver/params#Entity
          if (args.entities[i]) {
            params['entities'][i] = {};
            params['entities'][i]['tag'] = args.entities[i].tag;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'RemoteRelations',
        request: 'Relations',
        version: 1,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#RemoteRelationResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#RemoteRelationResult
            if (resp['results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
              // github.com/juju/juju/apiserver/params#RemoteRelation
              if (resp['results'][i]['result']) {
                result.results[i].result = {};
                // github.com/juju/juju/apiserver/params#Life
                result.results[i].result.life = resp['results'][i]['result']['life'];
                result.results[i].result.suspended = resp['results'][i]['result']['suspended'];
                result.results[i].result.id = resp['results'][i]['result']['id'];
                result.results[i].result.key = resp['results'][i]['result']['key'];
                result.results[i].result.applicationName = resp['results'][i]['result']['application-name'];
                // github.com/juju/juju/apiserver/params#RemoteEndpoint
                if (resp['results'][i]['result']['endpoint']) {
                  result.results[i].result.endpoint = {};
                  result.results[i].result.endpoint.name = resp['results'][i]['result']['endpoint']['name'];
                  // gopkg.in/juju/charm.v6#RelationRole
                  result.results[i].result.endpoint.role = resp['results'][i]['result']['endpoint']['role'];
                  result.results[i].result.endpoint.interface = resp['results'][i]['result']['endpoint']['interface'];
                  result.results[i].result.endpoint.limit = resp['results'][i]['result']['endpoint']['limit'];
                }
                result.results[i].result.remoteApplicationName = resp['results'][i]['result']['remote-application-name'];
                result.results[i].result.remoteEndpointName = resp['results'][i]['result']['remote-endpoint-name'];
                result.results[i].result.sourceModelUuid = resp['results'][i]['result']['source-model-uuid'];
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    RemoteApplications returns the current state of the remote applications
    with the specified names in the local model.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          entities: []{
            tag: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            result: {
              name: string,
              offerUuid: string,
              life: string,
              status: string,
              modelUuid: string,
              isConsumerProxy: bool,
              macaroon: anything
            },
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  remoteApplications(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#Entities
      if (args) {
        params = {};
        params['entities'] = [];
        args.entities = args.entities || [];
        for (let i = 0; i < args.entities.length; i++) {
          // github.com/juju/juju/apiserver/params#Entity
          if (args.entities[i]) {
            params['entities'][i] = {};
            params['entities'][i]['tag'] = args.entities[i].tag;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'RemoteRelations',
        request: 'RemoteApplications',
        version: 1,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#RemoteApplicationResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#RemoteApplicationResult
            if (resp['results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/apiserver/params#RemoteApplication
              if (resp['results'][i]['result']) {
                result.results[i].result = {};
                result.results[i].result.name = resp['results'][i]['result']['name'];
                result.results[i].result.offerUuid = resp['results'][i]['result']['offer-uuid'];
                // github.com/juju/juju/apiserver/params#Life
                result.results[i].result.life = resp['results'][i]['result']['life'];
                result.results[i].result.status = resp['results'][i]['result']['status'];
                result.results[i].result.modelUuid = resp['results'][i]['result']['model-uuid'];
                result.results[i].result.isConsumerProxy = resp['results'][i]['result']['is-consumer-proxy'];
                // gopkg.in/macaroon.v2-unstable#Macaroon
                result.results[i].result.macaroon = resp['results'][i]['result']['macaroon'];
              }
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    SaveMacaroons saves the macaroons for the given entities.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          args: []{
            macaroon: anything,
            tag: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  saveMacaroons(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#EntityMacaroonArgs
      if (args) {
        params = {};
        params['Args'] = [];
        args.args = args.args || [];
        for (let i = 0; i < args.args.length; i++) {
          // github.com/juju/juju/apiserver/params#EntityMacaroonArg
          if (args.args[i]) {
            params['Args'][i] = {};
            // gopkg.in/macaroon.v2-unstable#Macaroon
            params['Args'][i]['macaroon'] = args.args[i].macaroon;
            params['Args'][i]['tag'] = args.args[i].tag;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'RemoteRelations',
        request: 'SaveMacaroons',
        version: 1,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ErrorResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#ErrorResult
            if (resp['results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    SetRemoteApplicationsStatus sets the status for the specified remote
    applications.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          entities: []{
            tag: string,
            status: string,
            info: string,
            data: map[string]anything
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  setRemoteApplicationsStatus(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#SetStatus
      if (args) {
        params = {};
        params['entities'] = [];
        args.entities = args.entities || [];
        for (let i = 0; i < args.entities.length; i++) {
          // github.com/juju/juju/apiserver/params#EntityStatusArgs
          if (args.entities[i]) {
            params['entities'][i] = {};
            params['entities'][i]['tag'] = args.entities[i].tag;
            params['entities'][i]['status'] = args.entities[i].status;
            params['entities'][i]['info'] = args.entities[i].info;
            params['entities'][i]['data'] = {};
            args.entities[i].data = args.entities[i].data || {};
            for (let k in args.entities[i].data) {
              params['entities'][i]['data'][k] = args.entities[i].data[k];
            }
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'RemoteRelations',
        request: 'SetRemoteApplicationsStatus',
        version: 1,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ErrorResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#ErrorResult
            if (resp['results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    WatchLocalRelationUnits starts a RelationUnitsWatcher for watching the
    local relation units involved in each specified relation in the local
    model, and returns the watcher IDs and initial values, or an error if
    the relation units could not be watched.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          entities: []{
            tag: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            watcherId: string,
            changes: {
              changed: map[string]{
                version: int
              },
              departed: []string
            },
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  watchLocalRelationUnits(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#Entities
      if (args) {
        params = {};
        params['entities'] = [];
        args.entities = args.entities || [];
        for (let i = 0; i < args.entities.length; i++) {
          // github.com/juju/juju/apiserver/params#Entity
          if (args.entities[i]) {
            params['entities'][i] = {};
            params['entities'][i]['tag'] = args.entities[i].tag;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'RemoteRelations',
        request: 'WatchLocalRelationUnits',
        version: 1,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#RelationUnitsWatchResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#RelationUnitsWatchResult
            if (resp['results'][i]) {
              result.results[i] = {};
              result.results[i].watcherId = resp['results'][i]['watcher-id'];
              // github.com/juju/juju/apiserver/params#RelationUnitsChange
              if (resp['results'][i]['changes']) {
                result.results[i].changes = {};
                result.results[i].changes.changed = {};
                resp['results'][i]['changes']['changed'] = resp['results'][i]['changes']['changed'] || {};
                for (let k in resp['results'][i]['changes']['changed']) {
                  // github.com/juju/juju/apiserver/params#UnitSettings
                  if (resp['results'][i]['changes']['changed'][k]) {
                    result.results[i].changes.changed[k] = {};
                    result.results[i].changes.changed[k].version = resp['results'][i]['changes']['changed'][k]['version'];
                  }
                }
                result.results[i].changes.departed = [];
                resp['results'][i]['changes']['departed'] = resp['results'][i]['changes']['departed'] || [];
                for (let i2 = 0; i2 < resp['results'][i]['changes']['departed'].length; i2++) {
                  result.results[i].changes.departed[i2] = resp['results'][i]['changes']['departed'][i2];
                }
              }
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    WatchRemoteApplicationRelations starts a StringsWatcher for watching the
    relations of each specified application in the local model, and returns
    the watcher IDs and initial values, or an error if the services'
    relations could not be watched.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          entities: []{
            tag: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            watcherId: string,
            changes: []string,
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  watchRemoteApplicationRelations(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#Entities
      if (args) {
        params = {};
        params['entities'] = [];
        args.entities = args.entities || [];
        for (let i = 0; i < args.entities.length; i++) {
          // github.com/juju/juju/apiserver/params#Entity
          if (args.entities[i]) {
            params['entities'][i] = {};
            params['entities'][i]['tag'] = args.entities[i].tag;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'RemoteRelations',
        request: 'WatchRemoteApplicationRelations',
        version: 1,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#StringsWatchResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#StringsWatchResult
            if (resp['results'][i]) {
              result.results[i] = {};
              result.results[i].watcherId = resp['results'][i]['watcher-id'];
              result.results[i].changes = [];
              resp['results'][i]['changes'] = resp['results'][i]['changes'] || [];
              for (let i2 = 0; i2 < resp['results'][i]['changes'].length; i2++) {
                result.results[i].changes[i2] = resp['results'][i]['changes'][i2];
              }
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    WatchRemoteApplications starts a strings watcher that notifies of the
    addition, removal, and lifecycle changes of remote applications in the
    model; and returns the watcher ID and initial IDs of remote
    applications, or an error if watching failed.

    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          watcherId: string,
          changes: []string,
          error: {
            message: string,
            code: string,
            info: {
              macaroon: anything,
              macaroonPath: string
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  watchRemoteApplications(callback) {
    return new Promise((resolve, reject) => {
      const params = {};
      // Prepare the request to the Juju API.
      const req = {
        type: 'RemoteRelations',
        request: 'WatchRemoteApplications',
        version: 1,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#StringsWatchResult
        if (resp) {
          result = {};
          result.watcherId = resp['watcher-id'];
          result.changes = [];
          resp['changes'] = resp['changes'] || [];
          for (let i = 0; i < resp['changes'].length; i++) {
            result.changes[i] = resp['changes'][i];
          }
          // github.com/juju/juju/apiserver/params#Error
          if (resp['error']) {
            result.error = {};
            result.error.message = resp['error']['message'];
            result.error.code = resp['error']['code'];
            // github.com/juju/juju/apiserver/params#ErrorInfo
            if (resp['error']['info']) {
              result.error.info = {};
              // gopkg.in/macaroon.v2-unstable#Macaroon
              result.error.info.macaroon = resp['error']['info']['macaroon'];
              result.error.info.macaroonPath = resp['error']['info']['macaroon-path'];
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    WatchRemoteRelations starts a strings watcher that notifies of the
    addition, removal, and lifecycle changes of remote relations in the
    model; and returns the watcher ID and initial IDs of remote relations,
    or an error if watching failed.

    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          watcherId: string,
          changes: []string,
          error: {
            message: string,
            code: string,
            info: {
              macaroon: anything,
              macaroonPath: string
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  watchRemoteRelations(callback) {
    return new Promise((resolve, reject) => {
      const params = {};
      // Prepare the request to the Juju API.
      const req = {
        type: 'RemoteRelations',
        request: 'WatchRemoteRelations',
        version: 1,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#StringsWatchResult
        if (resp) {
          result = {};
          result.watcherId = resp['watcher-id'];
          result.changes = [];
          resp['changes'] = resp['changes'] || [];
          for (let i = 0; i < resp['changes'].length; i++) {
            result.changes[i] = resp['changes'][i];
          }
          // github.com/juju/juju/apiserver/params#Error
          if (resp['error']) {
            result.error = {};
            result.error.message = resp['error']['message'];
            result.error.code = resp['error']['code'];
            // github.com/juju/juju/apiserver/params#ErrorInfo
            if (resp['error']['info']) {
              result.error.info = {};
              // gopkg.in/macaroon.v2-unstable#Macaroon
              result.error.info.macaroon = resp['error']['info']['macaroon'];
              result.error.info.macaroonPath = resp['error']['info']['macaroon-path'];
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }
}


const wrappers = require('../wrappers.js');
if (wrappers.wrapRemoteRelations) {
  // Decorate the facade class in order to improve user experience.
  RemoteRelationsV1 = wrappers.wrapRemoteRelations(RemoteRelationsV1);
}

module.exports = RemoteRelationsV1;