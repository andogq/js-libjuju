/**
  Juju Controller version 4.
  This API facade is available on controller connections.

  NOTE: this file has been generated by the generate command in js-libjuju
  on Fri 2018/11/16 13:11:58 UTC. Do not manually edit this file.
*/

'use strict';

const {autoBind, createAsyncHandler} = require('../transform.js');

/**
  ControllerAPIv4 provides the v4 Controller API. The only difference between
  this and v5 is that v4 doesn't have the UpdateControllerConfig method.
*/
class ControllerV4 {

  constructor(transport, info) {
    this._transport = transport;
    this._info = info;
    this.version = 4;

    // Automatically bind all methods to instances.
    autoBind(this);
  }

  /**
    AllModels allows controller administrators to get the list of all the
    models in the controller.

    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          userModels: []{
            model: {
              name: string,
              uuid: string,
              type: string,
              ownerTag: string
            },
            lastConnection: time
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  allModels(callback) {
    return new Promise((resolve, reject) => {
      const params = {};
      // Prepare the request to the Juju API.
      const req = {
        type: 'Controller',
        request: 'AllModels',
        version: 4,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#UserModelList
        if (resp) {
          result = {};
          result.userModels = [];
          resp['user-models'] = resp['user-models'] || [];
          for (let i = 0; i < resp['user-models'].length; i++) {
            // github.com/juju/juju/apiserver/params#UserModel
            if (resp['user-models'][i]) {
              result.userModels[i] = {};
              // github.com/juju/juju/apiserver/params#Model
              if (resp['user-models'][i]['model']) {
                result.userModels[i].model = {};
                result.userModels[i].model.name = resp['user-models'][i]['model']['name'];
                result.userModels[i].model.uuid = resp['user-models'][i]['model']['uuid'];
                result.userModels[i].model.type = resp['user-models'][i]['model']['type'];
                result.userModels[i].model.ownerTag = resp['user-models'][i]['model']['owner-tag'];
              }
              // time#Time
              result.userModels[i].lastConnection = resp['user-models'][i]['last-connection'];
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    CloudSpec returns the model's cloud spec.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          entities: []{
            tag: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            result: {
              type: string,
              name: string,
              region: string,
              endpoint: string,
              identityEndpoint: string,
              storageEndpoint: string,
              credential: {
                authType: string,
                attrs: map[string]string,
                redacted: []string
              },
              cacertificates: []string
            },
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  cloudSpec(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#Entities
      if (args) {
        params = {};
        params['entities'] = [];
        args.entities = args.entities || [];
        for (let i = 0; i < args.entities.length; i++) {
          // github.com/juju/juju/apiserver/params#Entity
          if (args.entities[i]) {
            params['entities'][i] = {};
            params['entities'][i]['tag'] = args.entities[i].tag;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Controller',
        request: 'CloudSpec',
        version: 4,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#CloudSpecResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#CloudSpecResult
            if (resp['results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/apiserver/params#CloudSpec
              if (resp['results'][i]['result']) {
                result.results[i].result = {};
                result.results[i].result.type = resp['results'][i]['result']['type'];
                result.results[i].result.name = resp['results'][i]['result']['name'];
                result.results[i].result.region = resp['results'][i]['result']['region'];
                result.results[i].result.endpoint = resp['results'][i]['result']['endpoint'];
                result.results[i].result.identityEndpoint = resp['results'][i]['result']['identity-endpoint'];
                result.results[i].result.storageEndpoint = resp['results'][i]['result']['storage-endpoint'];
                // github.com/juju/juju/apiserver/params#CloudCredential
                if (resp['results'][i]['result']['credential']) {
                  result.results[i].result.credential = {};
                  result.results[i].result.credential.authType = resp['results'][i]['result']['credential']['auth-type'];
                  result.results[i].result.credential.attrs = {};
                  resp['results'][i]['result']['credential']['attrs'] = resp['results'][i]['result']['credential']['attrs'] || {};
                  for (let k in resp['results'][i]['result']['credential']['attrs']) {
                    result.results[i].result.credential.attrs[k] = resp['results'][i]['result']['credential']['attrs'][k];
                  }
                  result.results[i].result.credential.redacted = [];
                  resp['results'][i]['result']['credential']['redacted'] = resp['results'][i]['result']['credential']['redacted'] || [];
                  for (let i2 = 0; i2 < resp['results'][i]['result']['credential']['redacted'].length; i2++) {
                    result.results[i].result.credential.redacted[i2] = resp['results'][i]['result']['credential']['redacted'][i2];
                  }
                }
                result.results[i].result.cacertificates = [];
                resp['results'][i]['result']['cacertificates'] = resp['results'][i]['result']['cacertificates'] || [];
                for (let i2 = 0; i2 < resp['results'][i]['result']['cacertificates'].length; i2++) {
                  result.results[i].result.cacertificates[i2] = resp['results'][i]['result']['cacertificates'][i2];
                }
              }
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    ControllerAPIInfoForModels returns the controller api connection details
    for the specified models.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          entities: []{
            tag: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            addresses: []string,
            cacert: string,
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  controllerAPIInfoForModels(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#Entities
      if (args) {
        params = {};
        params['entities'] = [];
        args.entities = args.entities || [];
        for (let i = 0; i < args.entities.length; i++) {
          // github.com/juju/juju/apiserver/params#Entity
          if (args.entities[i]) {
            params['entities'][i] = {};
            params['entities'][i]['tag'] = args.entities[i].tag;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Controller',
        request: 'ControllerAPIInfoForModels',
        version: 4,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ControllerAPIInfoResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#ControllerAPIInfoResult
            if (resp['results'][i]) {
              result.results[i] = {};
              result.results[i].addresses = [];
              resp['results'][i]['addresses'] = resp['results'][i]['addresses'] || [];
              for (let i2 = 0; i2 < resp['results'][i]['addresses'].length; i2++) {
                result.results[i].addresses[i2] = resp['results'][i]['addresses'][i2];
              }
              result.results[i].cacert = resp['results'][i]['cacert'];
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    ControllerConfig returns the controller's configuration.

    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          config: map[string]anything
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  controllerConfig(callback) {
    return new Promise((resolve, reject) => {
      const params = {};
      // Prepare the request to the Juju API.
      const req = {
        type: 'Controller',
        request: 'ControllerConfig',
        version: 4,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ControllerConfigResult
        if (resp) {
          result = {};
          // github.com/juju/juju/apiserver/params#ControllerConfig
          result.config = {};
          resp['config'] = resp['config'] || {};
          for (let k in resp['config']) {
            result.config[k] = resp['config'][k];
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    DestroyController destroys the controller.  If the args specify the
    destruction of the models, this method will attempt to do so.
    Otherwise, if the controller has any non-empty, non-Dead hosted models,
    then an error with the code params.CodeHasHostedModels will be
    transmitted.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          destroyModels: bool,
          destroyStorage: bool
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error or null if the operation succeeded.
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  destroyController(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#DestroyControllerArgs
      if (args) {
        params = {};
        params['destroy-models'] = args.destroyModels;
        params['destroy-storage'] = args.destroyStorage;
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Controller',
        request: 'DestroyController',
        version: 4,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    GetCloudSpec constructs the CloudSpec for a validated and authorized model.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        <object>
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          result: {
            type: string,
            name: string,
            region: string,
            endpoint: string,
            identityEndpoint: string,
            storageEndpoint: string,
            credential: {
              authType: string,
              attrs: map[string]string,
              redacted: []string
            },
            cacertificates: []string
          },
          error: {
            message: string,
            code: string,
            info: {
              macaroon: anything,
              macaroonPath: string
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  getCloudSpec(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // gopkg.in/juju/names.v2#ModelTag
      if (args) {
        params = {};
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Controller',
        request: 'GetCloudSpec',
        version: 4,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#CloudSpecResult
        if (resp) {
          result = {};
          // github.com/juju/juju/apiserver/params#CloudSpec
          if (resp['result']) {
            result.result = {};
            result.result.type = resp['result']['type'];
            result.result.name = resp['result']['name'];
            result.result.region = resp['result']['region'];
            result.result.endpoint = resp['result']['endpoint'];
            result.result.identityEndpoint = resp['result']['identity-endpoint'];
            result.result.storageEndpoint = resp['result']['storage-endpoint'];
            // github.com/juju/juju/apiserver/params#CloudCredential
            if (resp['result']['credential']) {
              result.result.credential = {};
              result.result.credential.authType = resp['result']['credential']['auth-type'];
              result.result.credential.attrs = {};
              resp['result']['credential']['attrs'] = resp['result']['credential']['attrs'] || {};
              for (let k in resp['result']['credential']['attrs']) {
                result.result.credential.attrs[k] = resp['result']['credential']['attrs'][k];
              }
              result.result.credential.redacted = [];
              resp['result']['credential']['redacted'] = resp['result']['credential']['redacted'] || [];
              for (let i = 0; i < resp['result']['credential']['redacted'].length; i++) {
                result.result.credential.redacted[i] = resp['result']['credential']['redacted'][i];
              }
            }
            result.result.cacertificates = [];
            resp['result']['cacertificates'] = resp['result']['cacertificates'] || [];
            for (let i = 0; i < resp['result']['cacertificates'].length; i++) {
              result.result.cacertificates[i] = resp['result']['cacertificates'][i];
            }
          }
          // github.com/juju/juju/apiserver/params#Error
          if (resp['error']) {
            result.error = {};
            result.error.message = resp['error']['message'];
            result.error.code = resp['error']['code'];
            // github.com/juju/juju/apiserver/params#ErrorInfo
            if (resp['error']['info']) {
              result.error.info = {};
              // gopkg.in/macaroon.v2-unstable#Macaroon
              result.error.info.macaroon = resp['error']['info']['macaroon'];
              result.error.info.macaroonPath = resp['error']['info']['macaroon-path'];
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    GetControllerAccess returns the level of access the specified users have on
    the controller.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          entities: []{
            tag: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            result: {
              userTag: string,
              access: string
            },
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  getControllerAccess(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#Entities
      if (args) {
        params = {};
        params['entities'] = [];
        args.entities = args.entities || [];
        for (let i = 0; i < args.entities.length; i++) {
          // github.com/juju/juju/apiserver/params#Entity
          if (args.entities[i]) {
            params['entities'][i] = {};
            params['entities'][i]['tag'] = args.entities[i].tag;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Controller',
        request: 'GetControllerAccess',
        version: 4,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#UserAccessResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#UserAccessResult
            if (resp['results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/apiserver/params#UserAccess
              if (resp['results'][i]['result']) {
                result.results[i].result = {};
                result.results[i].result.userTag = resp['results'][i]['result']['user-tag'];
                result.results[i].result.access = resp['results'][i]['result']['access'];
              }
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    HostedModelConfigs returns all the information that the client needs in
    order to connect directly with the host model's provider and destroy it
    directly.

    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          models: []{
            name: string,
            owner: string,
            config: map[string]anything,
            cloudSpec: {
              type: string,
              name: string,
              region: string,
              endpoint: string,
              identityEndpoint: string,
              storageEndpoint: string,
              credential: {
                authType: string,
                attrs: map[string]string,
                redacted: []string
              },
              cacertificates: []string
            },
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  hostedModelConfigs(callback) {
    return new Promise((resolve, reject) => {
      const params = {};
      // Prepare the request to the Juju API.
      const req = {
        type: 'Controller',
        request: 'HostedModelConfigs',
        version: 4,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#HostedModelConfigsResults
        if (resp) {
          result = {};
          result.models = [];
          resp['models'] = resp['models'] || [];
          for (let i = 0; i < resp['models'].length; i++) {
            // github.com/juju/juju/apiserver/params#HostedModelConfig
            if (resp['models'][i]) {
              result.models[i] = {};
              result.models[i].name = resp['models'][i]['name'];
              result.models[i].owner = resp['models'][i]['owner'];
              result.models[i].config = {};
              resp['models'][i]['config'] = resp['models'][i]['config'] || {};
              for (let k in resp['models'][i]['config']) {
                result.models[i].config[k] = resp['models'][i]['config'][k];
              }
              // github.com/juju/juju/apiserver/params#CloudSpec
              if (resp['models'][i]['cloud-spec']) {
                result.models[i].cloudSpec = {};
                result.models[i].cloudSpec.type = resp['models'][i]['cloud-spec']['type'];
                result.models[i].cloudSpec.name = resp['models'][i]['cloud-spec']['name'];
                result.models[i].cloudSpec.region = resp['models'][i]['cloud-spec']['region'];
                result.models[i].cloudSpec.endpoint = resp['models'][i]['cloud-spec']['endpoint'];
                result.models[i].cloudSpec.identityEndpoint = resp['models'][i]['cloud-spec']['identity-endpoint'];
                result.models[i].cloudSpec.storageEndpoint = resp['models'][i]['cloud-spec']['storage-endpoint'];
                // github.com/juju/juju/apiserver/params#CloudCredential
                if (resp['models'][i]['cloud-spec']['credential']) {
                  result.models[i].cloudSpec.credential = {};
                  result.models[i].cloudSpec.credential.authType = resp['models'][i]['cloud-spec']['credential']['auth-type'];
                  result.models[i].cloudSpec.credential.attrs = {};
                  resp['models'][i]['cloud-spec']['credential']['attrs'] = resp['models'][i]['cloud-spec']['credential']['attrs'] || {};
                  for (let k in resp['models'][i]['cloud-spec']['credential']['attrs']) {
                    result.models[i].cloudSpec.credential.attrs[k] = resp['models'][i]['cloud-spec']['credential']['attrs'][k];
                  }
                  result.models[i].cloudSpec.credential.redacted = [];
                  resp['models'][i]['cloud-spec']['credential']['redacted'] = resp['models'][i]['cloud-spec']['credential']['redacted'] || [];
                  for (let i2 = 0; i2 < resp['models'][i]['cloud-spec']['credential']['redacted'].length; i2++) {
                    result.models[i].cloudSpec.credential.redacted[i2] = resp['models'][i]['cloud-spec']['credential']['redacted'][i2];
                  }
                }
                result.models[i].cloudSpec.cacertificates = [];
                resp['models'][i]['cloud-spec']['cacertificates'] = resp['models'][i]['cloud-spec']['cacertificates'] || [];
                for (let i2 = 0; i2 < resp['models'][i]['cloud-spec']['cacertificates'].length; i2++) {
                  result.models[i].cloudSpec.cacertificates[i2] = resp['models'][i]['cloud-spec']['cacertificates'][i2];
                }
              }
              // github.com/juju/juju/apiserver/params#Error
              if (resp['models'][i]['error']) {
                result.models[i].error = {};
                result.models[i].error.message = resp['models'][i]['error']['message'];
                result.models[i].error.code = resp['models'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['models'][i]['error']['info']) {
                  result.models[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.models[i].error.info.macaroon = resp['models'][i]['error']['info']['macaroon'];
                  result.models[i].error.info.macaroonPath = resp['models'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    InitiateMigration attempts to begin the migration of one or more models to
    other controllers.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          specs: []{
            modelTag: string,
            targetInfo: {
              controllerTag: string,
              addrs: []string,
              caCert: string,
              authTag: string,
              password: string,
              macaroons: string
            }
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            modelTag: string,
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            },
            migrationId: string
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  initiateMigration(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#InitiateMigrationArgs
      if (args) {
        params = {};
        params['specs'] = [];
        args.specs = args.specs || [];
        for (let i = 0; i < args.specs.length; i++) {
          // github.com/juju/juju/apiserver/params#MigrationSpec
          if (args.specs[i]) {
            params['specs'][i] = {};
            params['specs'][i]['model-tag'] = args.specs[i].modelTag;
            // github.com/juju/juju/apiserver/params#MigrationTargetInfo
            if (args.specs[i].targetInfo) {
              params['specs'][i]['target-info'] = {};
              params['specs'][i]['target-info']['controller-tag'] = args.specs[i].targetInfo.controllerTag;
              params['specs'][i]['target-info']['addrs'] = [];
              args.specs[i].targetInfo.addrs = args.specs[i].targetInfo.addrs || [];
              for (let i2 = 0; i2 < args.specs[i].targetInfo.addrs.length; i2++) {
                params['specs'][i]['target-info']['addrs'][i2] = args.specs[i].targetInfo.addrs[i2];
              }
              params['specs'][i]['target-info']['ca-cert'] = args.specs[i].targetInfo.caCert;
              params['specs'][i]['target-info']['auth-tag'] = args.specs[i].targetInfo.authTag;
              params['specs'][i]['target-info']['password'] = args.specs[i].targetInfo.password;
              params['specs'][i]['target-info']['macaroons'] = args.specs[i].targetInfo.macaroons;
            }
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Controller',
        request: 'InitiateMigration',
        version: 4,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#InitiateMigrationResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#InitiateMigrationResult
            if (resp['results'][i]) {
              result.results[i] = {};
              result.results[i].modelTag = resp['results'][i]['model-tag'];
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
              result.results[i].migrationId = resp['results'][i]['migration-id'];
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    ListBlockedModels returns a list of all models on the controller which have
    a block in place.  The resulting slice is sorted by model name, then
    owner. Callers must be controller administrators to retrieve the list.

    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          models: []{
            name: string,
            modelUuid: string,
            ownerTag: string,
            blocks: []string
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  listBlockedModels(callback) {
    return new Promise((resolve, reject) => {
      const params = {};
      // Prepare the request to the Juju API.
      const req = {
        type: 'Controller',
        request: 'ListBlockedModels',
        version: 4,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ModelBlockInfoList
        if (resp) {
          result = {};
          result.models = [];
          resp['models'] = resp['models'] || [];
          for (let i = 0; i < resp['models'].length; i++) {
            // github.com/juju/juju/apiserver/params#ModelBlockInfo
            if (resp['models'][i]) {
              result.models[i] = {};
              result.models[i].name = resp['models'][i]['name'];
              result.models[i].modelUuid = resp['models'][i]['model-uuid'];
              result.models[i].ownerTag = resp['models'][i]['owner-tag'];
              result.models[i].blocks = [];
              resp['models'][i]['blocks'] = resp['models'][i]['blocks'] || [];
              for (let i2 = 0; i2 < resp['models'][i]['blocks'].length; i2++) {
                result.models[i].blocks[i2] = resp['models'][i]['blocks'][i2];
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    ModelConfig returns the model config for the controller model.  For
    information on the current model, use client.ModelGet

    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          config: map[string]{
            value: anything,
            source: string
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  modelConfig(callback) {
    return new Promise((resolve, reject) => {
      const params = {};
      // Prepare the request to the Juju API.
      const req = {
        type: 'Controller',
        request: 'ModelConfig',
        version: 4,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ModelConfigResults
        if (resp) {
          result = {};
          result.config = {};
          resp['config'] = resp['config'] || {};
          for (let k in resp['config']) {
            // github.com/juju/juju/apiserver/params#ConfigValue
            if (resp['config'][k]) {
              result.config[k] = {};
              result.config[k].value = resp['config'][k]['value'];
              result.config[k].source = resp['config'][k]['source'];
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    ModelStatus returns a summary of the model.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          entities: []{
            tag: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          models: []{
            modelTag: string,
            life: string,
            hostedMachineCount: int,
            applicationCount: int,
            ownerTag: string,
            machines: []{
              id: string,
              hardware: {
                arch: string,
                mem: int,
                rootDisk: int,
                cores: int,
                cpuPower: int,
                tags: []string,
                availabilityZone: string
              },
              instanceId: string,
              status: string,
              hasVote: bool,
              wantsVote: bool
            },
            volumes: []{
              id: string,
              providerId: string,
              status: string,
              detachable: bool
            },
            filesystems: []{
              id: string,
              providerId: string,
              status: string,
              detachable: bool
            },
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  modelStatus(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#Entities
      if (args) {
        params = {};
        params['entities'] = [];
        args.entities = args.entities || [];
        for (let i = 0; i < args.entities.length; i++) {
          // github.com/juju/juju/apiserver/params#Entity
          if (args.entities[i]) {
            params['entities'][i] = {};
            params['entities'][i]['tag'] = args.entities[i].tag;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Controller',
        request: 'ModelStatus',
        version: 4,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ModelStatusResults
        if (resp) {
          result = {};
          result.models = [];
          resp['models'] = resp['models'] || [];
          for (let i = 0; i < resp['models'].length; i++) {
            // github.com/juju/juju/apiserver/params#ModelStatus
            if (resp['models'][i]) {
              result.models[i] = {};
              result.models[i].modelTag = resp['models'][i]['model-tag'];
              // github.com/juju/juju/apiserver/params#Life
              result.models[i].life = resp['models'][i]['life'];
              result.models[i].hostedMachineCount = resp['models'][i]['hosted-machine-count'];
              result.models[i].applicationCount = resp['models'][i]['application-count'];
              result.models[i].ownerTag = resp['models'][i]['owner-tag'];
              result.models[i].machines = [];
              resp['models'][i]['machines'] = resp['models'][i]['machines'] || [];
              for (let i2 = 0; i2 < resp['models'][i]['machines'].length; i2++) {
                // github.com/juju/juju/apiserver/params#ModelMachineInfo
                if (resp['models'][i]['machines'][i2]) {
                  result.models[i].machines[i2] = {};
                  result.models[i].machines[i2].id = resp['models'][i]['machines'][i2]['id'];
                  // github.com/juju/juju/apiserver/params#MachineHardware
                  if (resp['models'][i]['machines'][i2]['hardware']) {
                    result.models[i].machines[i2].hardware = {};
                    result.models[i].machines[i2].hardware.arch = resp['models'][i]['machines'][i2]['hardware']['arch'];
                    result.models[i].machines[i2].hardware.mem = resp['models'][i]['machines'][i2]['hardware']['mem'];
                    result.models[i].machines[i2].hardware.rootDisk = resp['models'][i]['machines'][i2]['hardware']['root-disk'];
                    result.models[i].machines[i2].hardware.cores = resp['models'][i]['machines'][i2]['hardware']['cores'];
                    result.models[i].machines[i2].hardware.cpuPower = resp['models'][i]['machines'][i2]['hardware']['cpu-power'];
                    result.models[i].machines[i2].hardware.tags = [];
                    resp['models'][i]['machines'][i2]['hardware']['tags'] = resp['models'][i]['machines'][i2]['hardware']['tags'] || [];
                    for (let i3 = 0; i3 < resp['models'][i]['machines'][i2]['hardware']['tags'].length; i3++) {
                      result.models[i].machines[i2].hardware.tags[i3] = resp['models'][i]['machines'][i2]['hardware']['tags'][i3];
                    }
                    result.models[i].machines[i2].hardware.availabilityZone = resp['models'][i]['machines'][i2]['hardware']['availability-zone'];
                  }
                  result.models[i].machines[i2].instanceId = resp['models'][i]['machines'][i2]['instance-id'];
                  result.models[i].machines[i2].status = resp['models'][i]['machines'][i2]['status'];
                  result.models[i].machines[i2].hasVote = resp['models'][i]['machines'][i2]['has-vote'];
                  result.models[i].machines[i2].wantsVote = resp['models'][i]['machines'][i2]['wants-vote'];
                }
              }
              result.models[i].volumes = [];
              resp['models'][i]['volumes'] = resp['models'][i]['volumes'] || [];
              for (let i2 = 0; i2 < resp['models'][i]['volumes'].length; i2++) {
                // github.com/juju/juju/apiserver/params#ModelVolumeInfo
                if (resp['models'][i]['volumes'][i2]) {
                  result.models[i].volumes[i2] = {};
                  result.models[i].volumes[i2].id = resp['models'][i]['volumes'][i2]['id'];
                  result.models[i].volumes[i2].providerId = resp['models'][i]['volumes'][i2]['provider-id'];
                  result.models[i].volumes[i2].status = resp['models'][i]['volumes'][i2]['status'];
                  result.models[i].volumes[i2].detachable = resp['models'][i]['volumes'][i2]['detachable'];
                }
              }
              result.models[i].filesystems = [];
              resp['models'][i]['filesystems'] = resp['models'][i]['filesystems'] || [];
              for (let i2 = 0; i2 < resp['models'][i]['filesystems'].length; i2++) {
                // github.com/juju/juju/apiserver/params#ModelFilesystemInfo
                if (resp['models'][i]['filesystems'][i2]) {
                  result.models[i].filesystems[i2] = {};
                  result.models[i].filesystems[i2].id = resp['models'][i]['filesystems'][i2]['id'];
                  result.models[i].filesystems[i2].providerId = resp['models'][i]['filesystems'][i2]['provider-id'];
                  result.models[i].filesystems[i2].status = resp['models'][i]['filesystems'][i2]['status'];
                  result.models[i].filesystems[i2].detachable = resp['models'][i]['filesystems'][i2]['detachable'];
                }
              }
              // github.com/juju/juju/apiserver/params#Error
              if (resp['models'][i]['error']) {
                result.models[i].error = {};
                result.models[i].error.message = resp['models'][i]['error']['message'];
                result.models[i].error.code = resp['models'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['models'][i]['error']['info']) {
                  result.models[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.models[i].error.info.macaroon = resp['models'][i]['error']['info']['macaroon'];
                  result.models[i].error.info.macaroonPath = resp['models'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    ModifyControllerAccess changes the model access granted to users.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          changes: []{
            userTag: string,
            action: string,
            access: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            error: {
              message: string,
              code: string,
              info: {
                macaroon: anything,
                macaroonPath: string
              }
            }
          }
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  modifyControllerAccess(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#ModifyControllerAccessRequest
      if (args) {
        params = {};
        params['changes'] = [];
        args.changes = args.changes || [];
        for (let i = 0; i < args.changes.length; i++) {
          // github.com/juju/juju/apiserver/params#ModifyControllerAccess
          if (args.changes[i]) {
            params['changes'][i] = {};
            params['changes'][i]['user-tag'] = args.changes[i].userTag;
            // github.com/juju/juju/apiserver/params#ControllerAction
            params['changes'][i]['action'] = args.changes[i].action;
            params['changes'][i]['access'] = args.changes[i].access;
          }
        }
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Controller',
        request: 'ModifyControllerAccess',
        version: 4,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#ErrorResults
        if (resp) {
          result = {};
          result.results = [];
          resp['results'] = resp['results'] || [];
          for (let i = 0; i < resp['results'].length; i++) {
            // github.com/juju/juju/apiserver/params#ErrorResult
            if (resp['results'][i]) {
              result.results[i] = {};
              // github.com/juju/juju/apiserver/params#Error
              if (resp['results'][i]['error']) {
                result.results[i].error = {};
                result.results[i].error.message = resp['results'][i]['error']['message'];
                result.results[i].error.code = resp['results'][i]['error']['code'];
                // github.com/juju/juju/apiserver/params#ErrorInfo
                if (resp['results'][i]['error']['info']) {
                  result.results[i].error.info = {};
                  // gopkg.in/macaroon.v2-unstable#Macaroon
                  result.results[i].error.info.macaroon = resp['results'][i]['error']['info']['macaroon'];
                  result.results[i].error.info.macaroonPath = resp['results'][i]['error']['info']['macaroon-path'];
                }
              }
            }
          }
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    RemoveBlocks removes all the blocks in the controller.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          all: bool
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error or null if the operation succeeded.
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  removeBlocks(args, callback) {
    return new Promise((resolve, reject) => {
      // Prepare request parameters.
      let params;
      // github.com/juju/juju/apiserver/params#RemoveBlocksArgs
      if (args) {
        params = {};
        params['all'] = args.all;
      }
      // Prepare the request to the Juju API.
      const req = {
        type: 'Controller',
        request: 'RemoveBlocks',
        version: 4,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }

  /**
    WatchAllModels starts watching events for all models in the controller. The
    returned AllWatcherId should be used with Next on the AllModelWatcher
    endpoint to receive deltas.

    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          watcherId: string
        }
    @return {Promise} Rejected or resolved with the values normally passed to
      the callback when the callback is not provided.
      This allows this method to be awaited.
  */
  watchAllModels(callback) {
    return new Promise((resolve, reject) => {
      const params = {};
      // Prepare the request to the Juju API.
      const req = {
        type: 'Controller',
        request: 'WatchAllModels',
        version: 4,
        params: params
      };
      // Define a transform method if necessary.
      let transform = null;
      transform = resp => {
        let result;
        // github.com/juju/juju/apiserver/params#AllWatcherId
        if (resp) {
          result = {};
          result.watcherId = resp['watcher-id'];
        }
        return result;
      };

      const handler = createAsyncHandler(callback, resolve, reject, transform);
      // Send the request to the server.
      this._transport.write(req, handler);
    });
  }
}


const wrappers = require('../wrappers.js');
if (wrappers.wrapController) {
  // Decorate the facade class in order to improve user experience.
  ControllerV4 = wrappers.wrapController(ControllerV4);
}

module.exports = ControllerV4;